---
title: DevOps - 有效管理三方组件(07)
author:
  name: superhsc
  link: https://github.com/happymaya
date: 2020-02-29 10:33:00 +0800
categories: [DevOps]
tags: [DevOps]
math: true
mermaid: true
image:
  src: https://images.happymaya.cn/assert/devops/devops.png
  width: 800
  height: 500
---

依赖组件也是一个非常烦人的问题

比如，依赖组件的某个版本存在缺陷或安全漏洞，不再继续使用。不管是第三方的依赖组件，还是企业内部开发的依赖组件，这类问题都是非常普遍的。

当发现组件有问题时，要能知道该组件的基本信息和影响范围，以及采取什么样的措施。

使得在节省时间和精力的同时，让系统更可控。这也是我在之前的企业中落地的一个实践。

# 做第三方组件管理的原因

优点：
1. 可复用的三方组件让软件开发变得越来越简单
2. 第三方组件不是自己写的，可以直接拿来使用的代码，避免重复造轮子

缺点：
1. 存在缺陷或安全漏洞
2. 版本会过时
3. 额外的维护成本

随着系统的架构越来越复杂，需要依赖的组件也会越来越多，风险和成本也就越来越大。

使用第三方组件本质上是安全风险问题和增加维护成本与减少开发时间的回报之间的平衡问题。

通过第三方组件的有效管理，可以有效控制第三方组件产生的风险，这是要做第三方组件管理的主要原因。

# 第三方组件的管控方式

第三方组件是一个统称，范围很广，涉及任何开发语言。

本文的第三方组件主要指 Java 语言中，通过 Maven、Gradle 等构建管理工具添加到应用程序中的依赖组件。

为了后面更好的理解第三方组件的管理，这里先叙述第三方组件的表示方法和添加方式，进而引出最合适的管控时机。

## 表示方法
在 Maven、Gradle 等构建管理工具中，第三方组件的命名一般包含三部分。

**groupId**
- 所有项目中唯一标识
- 遵循 Java 的包名命名规则，即以反向域名开头
- 如 org.springframework.boot

**artifactId**
- 不包含版本的模块的名称
- 如 spring-boot-starter-test

**version**
- 当前模块的版本
- 一般为数字和点的形式，如 2.4.0
- 也会跟组件发布状态有关，如 SNAPSHOT 表示快照版，RELEASE 表示发布版本 |

## 添加方式
以 spring-boot-starter-test 依赖组件为例，介绍第三方组件的添加方式：
在 Maven 中，<dependency/> 表示一个第三方组件，将组件的坐标按如下格式添加到项目的 pom.xml 文件 <dependencies/> 中，即可完成添加。
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <version>2.4.0</version>
    <scope>test</scope>
</dependency>
```
在 Gradle 中，可将如下格式的依赖声明添加到 build.gradle 文件中的 dependencies 中，即可完成添加。
```
testCompile group: 'org.springframework.boot', name: 'spring-boot-starter-test', version: '2.4.0'
```

 
## 管控时机

构建管理工具在构建软件时会经过一系列的阶段，比如：**编译、测试、打包，安装、部署**等环节。

其中**编译**，是一个关键环节，是对第三方组件进行数据收集和管控的最好时机。

将第三方组件的坐标描述添加到文件中，并不会真正地将组件添加到项目中。

只有当触发编译时，构建管理工具才会根据仓库地址的设置进行读取。

一般情况下，为了加快读取的速度，会先在本地仓库中查找，如果没有再从远程仓库下载到本地）


# 第三方组件管理的需求

引入第三方组件存在风险和问题，也是影响软件交付质量的重要因素。

关于对第三方组件的管理，在现有的 DevOps 平台中增加了依赖管理的功能。主要的功能项目如下表：

**依赖扫描**
- 扫描系统的依赖数据并上传到服务器 

**依赖查询**
- 查询依赖组件的坐标信息，并按系统名、版本进行检索

**依赖管理**
- 维护依赖组件的坐标信息，黑白名单，控制策略和影响范围

**依赖控制**
- 在编译阶段对依赖组件进行检查，当检测到依赖组件中包含了黑名单中的组件，按照设置好的控制策略对该组件进行处理，比如编译失败，邮件通知负责人等

**依赖同步**
- 从远程仓库同步依赖组件的版本信息，判断该组件版本是否过时

**反向依赖**
- 按依赖组件查询应用系统。当发现组件有问题时，判断该组件的影响范围时非常有用

> 1. 黑名单指，不允许使用的组件；
2. 白名单是，可以使用的组件；
3. 控制策略，指的是当发现组件有问题时采取的措施，如阻断，警告；
4. 影响范围，指的该控制策略的应用范围，如当前系统，所有系统等。
{: .prompt-warning }


# 第三方组件管理的设计

实现上面的功能需求，下面从**架构设计**、**流程图设计**、**类图设计**和**接口设计**四个方面对第三方组件管理服务进行说明。

通过这四个方面的介绍，基本上就可以按照这个设计编码实现第三方组件管理功能了。

下面的图形主要展示的是设计的关键部分，在具体实现的过程中，可以根据实际情况进行扩展。

## 架构设计
第三方组件管理这个功能涉及的核心组件有两个：**依赖管理服务**和**持续集成平台**。

- **依赖管理服务。**
   - 用于维护依赖组件的信息，包含存储和查询依赖组件
   - 添加、修改和删除依赖组件的控制策略
   - 同步依赖组件的最新版本
   - 为前端提供数据查询接口等
- **持续集成平台。**
   - 用于在编译阶段对依赖组件进行扫描和扫描数据上报
   - 当发现有黑名单中的依赖组件时，根据依赖组件的控制策略进行处理

<iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:525px; height:245px;" src="https://www.processon.com/embed/61e3f0f27d9c0806a8aa1ca2"></iframe>

## 流程图设计
根据上面架构图的设计，第三方组件管理的业务流程图，如下图所示，包含2个主要的流程：**数据维护流程**和**依赖扫描流程**。

- **数据维护流程。**该流程比较简单，就是准备数据。比如：安全部门发现**fastjson<=1.2.62**存在远程代码执行的漏洞，公司里任何系统都不允许依赖该范围的版本。这时就可以将该依赖组件添加到黑名单，groupId 为**com.alibaba**，artifactId 为**fastjson**，version 为**1.2.62**，逻辑运算符为**<=**，控制策略为**阻断**，应用范围为**所有**。
- **依赖扫描流程。**这一部分是该功能的核心流程。由持续集成平台发起，分为以下几个步骤：
   1. 克隆代码库，编译源代码；
   2. 利用 maven 插件，执行依赖扫描任务，获取依赖组件信息；
   3. 调用依赖管理服务的接口获取黑名单列表；
   4. 判断扫描的依赖组件中是否包含黑名单中的组件；
   5. 如果有，则判断控制策略是否是阻断；
   6. 如果是阻断，则直接阻断当前任务，编译失败；
   7. 如果是警告，则输出警告信息，上传编译数据，编译通过；
   8. 如果不包含，则上传依赖数据，编译通过。

<iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:525px; height:245px;" src="https://www.processon.com/embed/61e3fca15653bb06cbc5da9b"></iframe>

## 类图设计

该功能涉及的几个关键类，如下图所示，主要有：DmService（服务类）、DmScanRecord（扫描记录类）、DmScanDependency（扫描依赖类）、DmDependency（依赖类）和 DmBlackList（黑名单类）。这几个类的用途是：

- **DmService（服务类）**：该类用于存储业务系统与代码库的关联关系。当进行反向依赖查询时，能知道该依赖组件有哪些系统在使用。
- **DmScanRecord（扫描记录类）**：该类用于存储每次的依赖扫描记录。为了能知道每次代码提交的依赖组件信息，一般要跟代码库、分支、CommitId 进行关联。
- **DmScanDependency（扫描依赖类）**：该类用于存储每次扫描的依赖组件信息，包含层次关系。当发现该组件有问题时，对该组件进行标记。为了减少存储的数据量，这里只存储依赖组件的ID信息，具体详细信息存储在 DmDependency 类中。
- **DmDependency（依赖类）**：该类用于存储具体的依赖组件信息，通过 groupId、artifactId、version、classifier 来标记唯一组件。
- **DmBlackList（黑名单类）**：该类用于存储依赖组件的黑名单信息。


## 接口设计
经过上面几个设计图，第三方组件管理功能基本上已经很清晰了，知道了有哪些组件以及组件的调用关系、数据维护和依赖扫描的流程、以及需要哪些类来存储这些元数据。那么，接口设计这部分，就是要**基于这些元数据，定义对外暴露的接口，将上面的流程串联起来，最终实现组件间的相互调用。**
![image.png](https://images.happymaya.cn/assert/devops/devops-07-1.png)



下面是按照 OpenApi 3.0 的规范编写的接口文档。数据维护相关的有：**服务管理和黑名单管理接口**。依赖扫描相关的有：黑名单查询和依赖上报接口。查询相关的有：依赖查询和反向依赖查询等

![image.png](https://images.happymaya.cn/assert/devops/devops-07-2.png)

这些就是第三方组件管理功能主要的设计内容，功能不是很复杂，但能达到有效管理和控制第三方组件的效果。通过嵌入到持续集成流程里，可以作为代码预检查的检查项，尽早发现有问题的组件。

