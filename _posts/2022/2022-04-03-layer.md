---
title: 分层思维：代码分层架构的必要性
author:
  name: superhsc
  link: https://github.com/happymaya
date: 2022-04-03 11:30:20 +0800
categories: [Design Pattern]
tags: [分层思维]
math: true
mermaid: true
---

软件程序通常有两个层面的需求：

- **功能性需求**，指的是一个程序能为用户做些什么，比如，文件上传、查询数据等；
- **非功能性需求**，指的是除功能性需求以外的其他必要需求，比如，性能、安全性、容错与恢复、本地化、国际化等。

事实上，**非功能性需求所构建起来的正是软件架构**。什么是软件架构？简单来说，就是软件的基本结构，包括三要素：

- 代码；
- 代码之间的关系；
- 两者各自的属性。

如果把软件比作一座高楼，那么软件架构就是那个钢筋混凝土的框架，代码就是那个框架里的砖石，正是因为有了那个框架，才能让每一个代码都能很好地运行起来。由此可见，软件架构的重要性。
其中，最为经典的软件架构就是**分层架构，**也就是将软件系统进行分层，现在几乎已经成为每个程序员最熟悉的思考模式之一。不过，分层架构越是流行，我们的设计就越容易僵化！！！
# 代码分层架构
要彻底理解**代码分层架构**，就得从**软件部署分层架构**说起。
首先，先看一下常见的互联网软件部署分层架构，如下图所示：
![图片.png](https://cdn.nlark.com/yuque/0/2022/png/12442250/1657695673389-316ffe24-4c15-454b-93a8-3aeb40cb3d50.png#clientId=uee0e223e-a7a7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=300&id=ud846caeb&margin=%5Bobject%20Object%5D&name=%E5%9B%BE%E7%89%87.png&originHeight=300&originWidth=348&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66238&status=done&style=none&taskId=u50ff8a6c-2adf-488f-a097-16bf38763ec&title=&width=348)

由上图可以看到，软件部署分层架构主要包括以下四个核心部分：

- 客户端层（Client）：调用方，比如浏览器或 App。
- 应用服务层的网页服务器（Web Server）：实现程序的运行逻辑，并从下层获取数据，返回给上层的客户端层。
- 应用服务层的缓存（Cache）：加速访问存储的数据。
- 数据层（DB）：存储数据。

由此可以，**软件分层架构是通过层来隔离不同的关注点（变化相似的地方）**，以此来解决不同需求变化的问题，使得这种变化可以被控制在一个层里。
作为软件开发者，更关心的是应用程序里的分层架构。比如，下图展示的 MVC 分层架构：
![图片.png](https://cdn.nlark.com/yuque/0/2022/png/12442250/1657695696883-f37475ec-949f-40c0-b640-2d6bb8e39c25.png#clientId=uee0e223e-a7a7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=297&id=u9a1b17b3&margin=%5Bobject%20Object%5D&name=%E5%9B%BE%E7%89%87.png&originHeight=297&originWidth=451&originalType=binary&ratio=1&rotation=0&showTitle=false&size=89293&status=done&style=none&taskId=u2072e3b7-f792-4afa-94c4-164b9436c40&title=&width=451)
明显看到，MVC 分层架构是作用于程序本身的，程序作为一个整体被发布在服务器上运行使用。由此可以，**代码分层架构就是将软件“元素”（代码）按照“层”（代码关系）的方式组织起来的一种结构。**
**分层架构核心的原则是：当请求或数据从外部传递过来后，必须是从上一层传递给下一层**。如下图，一个来自 View 层的数据，必须先通过 Controller 层、Model 层后，才能最终到达数据库层。
![图片.png](https://cdn.nlark.com/yuque/0/2022/png/12442250/1657695724317-0982463d-6b9a-4cb9-aa3b-9dbddbe9b68f.png#clientId=uee0e223e-a7a7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=289&id=u5e472180&margin=%5Bobject%20Object%5D&name=%E5%9B%BE%E7%89%87.png&originHeight=289&originWidth=446&originalType=binary&ratio=1&rotation=0&showTitle=false&size=182013&status=done&style=none&taskId=u154b0d7b-8d44-4a34-943c-c21c3b54a0e&title=&width=446)
“为什么不让 View 层的请求直接到达数据库呢？”这是因为会造成**新代码耦合，增加代码复杂度**。比如说，View 层直接调用 Model 层的组件，当 Model 层上的组件有变化时（比如， SQL 或逻辑修改），既会影响 Controller 层组件的使用，也会影响 View 层组件的使用（可参考下面的示意图）。  
![图片.png](https://cdn.nlark.com/yuque/0/2022/png/12442250/1657695750117-eb482258-7455-4981-bb4f-cdcf18a9e0e3.png#clientId=uee0e223e-a7a7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=u1e5e65ed&margin=%5Bobject%20Object%5D&name=%E5%9B%BE%E7%89%87.png&originHeight=261&originWidth=452&originalType=binary&ratio=1&rotation=0&showTitle=false&size=170126&status=done&style=none&taskId=ub80fc97a-89fd-48e4-903b-f6e423a02df&title=&width=452)
所以，**分层的本质就是为了让相似变化在各自的层内变化，而不造成层与层之间的相互影响。**
# 代码分层的作用
代码分层架构主要是为了解决两个问题：

- 如何快速拆解功能问题？
- 如何提升代码的可扩展性？

## 快速拆解问题
在软件开发中，一个功能需求问题通常都是笼统的复杂问题，我们一般都会将这个笼统的复杂问题拆分为多个层次的子问题来解决。
比如，正在编写一段“通过 HTTP 向服务器发送字符串”的代码，如下所示：
```java
//创建HTTP连接
URL url = new URL("http://xxx.test.com/sayHello");
HttpURLConnection connection = (HttpURLConnection) url.openConnection();
connection.connect();

//发送数据
OutputStream os = connection.getOutputStream();
os.write("Hello World!".getBytes("UTF-8"));

//接收响应
InputStream is = connection.getInputStream();
BufferedReader br = new BufferedReader(new InputStreamReader(is, "UTF-8"));

//……
br.close();
is.close();
os.close();

//关闭连接
connection.disconnect();

```
 可以将上面的代码，简单地抽象成一个流程图，如下所示：  
![图片.png](https://cdn.nlark.com/yuque/0/2022/png/12442250/1657695790103-5cde1e0d-b072-4cea-95da-2b240ddd00f5.png#clientId=uee0e223e-a7a7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=289&id=u1015ca63&margin=%5Bobject%20Object%5D&name=%E5%9B%BE%E7%89%87.png&originHeight=289&originWidth=175&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23055&status=done&style=none&taskId=ub5f7265d-86cc-48e1-878f-a02a174c87d&title=&width=175)

这个流程图代表了对最初始问题的分层拆分：先创建 HTTP 连接，然后向服务器发送一串字符串，最后关闭 HTTP 连接。
于是，原先的“如何通过 HTTP 向服务器发送字符串”的问题就变成了三个新层次的子问题：

- 如何创建 HTTP 连接？
- 如何发送字符串？
- 如何关闭连接？

首先，在思考如何创建 HTTP 连接这个问题的过程中，会发现，要想通过 HTTP 发送消息，至少得打开 HTTP 连接，建立 HTTP 会话，并使用 TCP 协议，这样才能通过网络发送数据。
接着，又发现，当成功解决了这个问题后，发送字符串和关闭 HTTP 连接还有更多的问题需要解决，于是，你开始一步一步地去分解……最后的分解结果如下图所示：
![图片.png](https://cdn.nlark.com/yuque/0/2022/png/12442250/1657695826273-e4850750-7c95-4914-8bae-521eaf7c7264.png#clientId=uee0e223e-a7a7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=390&id=u98c4a35e&margin=%5Bobject%20Object%5D&name=%E5%9B%BE%E7%89%87.png&originHeight=390&originWidth=407&originalType=binary&ratio=1&rotation=0&showTitle=false&size=77479&status=done&style=none&taskId=ue9749aa6-b100-4d72-999c-4d664cabe41&title=&width=407)
当所有子问题都被成功解决以后，最初通过 HTTP 向服务器发送字符串的总问题也就得以解决了。
这样，在不知不觉中就通过分层将一个复杂的大问题分解为多个容易解决的子层问题。而实际上，有的子层问题已经被前人解决过了，比如，如何使用 HTTP 协议来进行网络数据的通信。也就是说，**最后真正需要关注的问题其实变少了**。
所以说，从功能性需求角度来看，代码分层是一种拆解复杂问题的好方法。
## 提升代码可扩展性
分层架构的出现，除了解决拆分复杂问题的困境外，还解决了代码可扩展性的问题。
因为真实的系统数据一直在不断增加。比如说，一个电商网站的用户访问数会从一万个并发增长到十万个并发，或者从一百万增长到一千万。过去的单体架构之所以很难承载，是因为当需要扩展服务器和数据库功能时，一处的代码修改就会影响所有的功能。
分层架构可以将复杂的逻辑切分为多个层，这样大问题就变成了多个小问题，而我们可以很方便地解决每个小问题。每个小问题更容易被抽象为一个组件，当组件功能需要扩充或替换时，修改代码的影响也被有效地控制在有限的范围内，这样**组件自身的复用性也就提高了**。
除了提高代码组件之间的复用性外，分层架构还让我们**更容易做服务的横向扩展**。
简单来说，横向扩展就是用多台配置较低的服务器共同提供服务，也就是集群部署服务方式。比如说，将 Model 层抽取出来作为通用的数据服务部署，这样既不影响其他业务层，也能在负载增加时，快速扩展服务的承载能力。
# 代码分层架构的优点和缺点
## 优点
优点大致可总结为如下：

- 只用关注整个结构中的其中某一层的具体实现；
- 降低层与层之间的依赖；
- 很容易用新的实现来替换原有层次的实现；
- 有利于标准化的统一；
- 各层逻辑方便复用。

总结来说，代码分层架构设计主要为了**实现责任分离、解耦、组件复用和标准制定**。
如果不使用分层架构的话，代码逻辑肯定会紧紧依赖在一起，修改某一处必定影响其他很多处。
从软件项目的角度看，这样会造成非常严重的影响。比如，一个上传功能需要存入下载链接到数据库，如果没有分层，那么当修改存储的路径或类型时，还得修改存储数据库的业务逻辑，想想就很麻烦。
另外，层与层之间进行划分后，也提高了组件之间的复用性，层本身就是一种组件形式，通过统一的接口来与外界进行交互，而不再是按照功能上的依赖来进行交互。而统一的接口是模块之间相互约定的统一标准，只要按照标准来进行代码实现，就不会因为代码改动而影响接口的使用。
## 缺点
虽然代码分层有很多好处，但不可避免地也会有一些劣势。

- **开发成本变高**：因为不同层分别承担各自的责任，如果是高层次新增功能，则需要多个低层增加代码，这样难免会增加开发成本。
- **性能降低**：请求数据因为经过多层代码的处理，执行时长加长，性能会有所消耗。
- **代码复杂度增加**：因为层与层之间存在强耦合，所以对于一些组合功能的调用，则需要增加很多层之间的调用。
# 总结
软件分层架构是通过层来隔离不同的关注点（变化相似的地方），以此来解决不同需求变化的问题，使得这种变化可以被控制在一个层里。
代码分层架构的核心作用有两个：

- **对于功能性需求，将复杂问题分解为多个容易解决的子层问题；**
- **对于非功能性需求，可以提升代码可扩展性。**

总结来说，代码分层架构是一种软件架构设计方法。

- 从软件的功能性需求角度看，分层是为了把较大的复杂问题拆分为多个较小的问题，在分散问题风险的同时，让问题更容易被解决，也就是我们常说的解耦。
- 从架构（非功能性需求）角度看，分层能提升代码可扩展性，帮助开发人员在相似的变化中修改代码。

其实，**复杂的设计概念和简单的代码之间存在一种平衡**，这就是分层架构。

- 代码分层架构设计的思维模型是简化思维，本质是抽象与拆解。
- 代码分层架构设计的目的是将复杂问题拆分为更容易解决的小问题，降低实现难度。
- 代码分层架构设计的原则和方法是通用方法，可以应用到其他需要分层设计的地方。

所以，分层架构从来不是目的，只是让软件变得更好的其中一种思维方法而已。

除了分层架构外，其他架构设计模式：

- C/S模式：
   - 优点： 
      - 能充分发挥客户端PC的处理能力，很多工作可以在客户端处理后再提交给服务器，所以 CS 客户端响应速度快；
      - 操作界面漂亮、形式多样，可以充分满足客户自身的个性化要求；
      -  C/S 结构的管理信息系统具有较强的事务处理能力，能实现复杂的业务流程；
      - 安全性能可以很容易保证，C/S一般面向相对固定的用户群，程序更加注重流程，它可以对权限进行多层次校验，提供了更安全的存取模式，对信息安全的控制能力很强。一般高度机密的信息系统采用C/S结构适宜。
   - 缺点： 
      - 需要专门的客户端安装程序，分布功能弱，针对点多面广且不具备网络条件的用户群体，不能够实现快速部署安装和配置；
      - 兼容性差，对于不同的开发工具，具有较大的局限性。若采用不同工具，需要重新改写程序；
      - 开发、维护成本较高，需要具有一定专业水准的技术人员才能完成，发生一次升级，则所有客户端的程序都需要改变；
      - 用户群固定。由于程序需要安装才可使用，因此不适合面向一些不可知的用户，所以适用面窄，通常用于局域网中。
- 主备模式（Master-slave pattern） 
- 管道模式（Pipe-filter pattern） 
- 代理模式（Broker pattern） 
- 点对点模式（Peer-to-peer pattern） 
- 事件总线模式（Event-bus pattern） 
- MVC模式（Model-view-controller pattern） 
- 黑板模式（Blackboard pattern） 
- 解释器模式（Interpreter pattern）   
