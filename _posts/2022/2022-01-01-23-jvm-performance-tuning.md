---
title: 大型项目性能调优 —— JVM 
author:
  name: superhsc
  link: https://github.com/happymaya
date: 2022-01-01 15:03:00 +0800
categories: [Java, JVM]
tags: [JVM, JIT, JITWatch, 方法内联, 逃逸分析，编译层次]
math: true
mermaid: true
---

性能调优是一个非常大，并且非常模糊的话题。

在大型的项目中，既有分布式的交互式调优问题，也有纯粹的单机调优问题。

本文重点关注 JVM 的调优、故障或者性能瓶颈方面的问题排查！！！

## 优化层次

当一个系统出现问题的时候，一般不会想要立刻优化 JVM，会优先尝试从最高层次上进行问题的解决：解决最主要的瓶颈点。下面是一张关于优化层次的图，箭头表示优化时需要考虑的路径（也有例外）

![](https://images.happymaya.cn/assert/java/jvm/jvm-23-01.png)

### 数据库优化

 数据库是最容易成为瓶颈的组件，研发会从 SQL 优化或者数据库本身去提高它的性能。如果瓶颈依然存在，则会考虑分库分表将数据打散，如果这样也没能解决问题，则可能会选择缓存组件进行优化。这个过程与本课时相关的知识点，可以使用 jstack 获取阻塞的执行栈，进行辅助分析。

### 集群优化

存储节点的问题解决后，计算节点也有可能发生问题。一个集群系统如果获得了水平扩容的能力，就会给下层的优化提供非常大的时间空间，这也是弹性扩容的魅力所在。我接触过一个服务，由最初的 3 个节点，扩容到最后的 200 多个节点，但由于人力问题，服务又没有什么新的需求，下层的优化就一直被搁置着。

### 硬件升级

水平扩容不总是有效的，原因在于单节点的计算量比较集中，或者 JVM 对内存的使用超出了宿主机的承载范围。在动手进行代码优化之前，我们会对节点的硬件配置进行升级。升级容易，降级难，降级需要依赖代码和调优层面的优化。

### 代码优化

出于成本的考虑，上面的这些问题，研发团队并不总是坐视不管。代码优化是提高性能最有效的方式，但需要收集一些数据，这个过程可能是服务治理，也有可能是代码流程优化。我在第 21 课时介绍的 JavaAgent 技术，会无侵入的收集一些 profile 信息，供我们进行决策。像 Sonar 这种质量监控工具，也可以在此过程中帮助到我们。

### 并行优化

并行优化的对象是这样一种接口，它占用的资源不多，计算量也不大，就是速度太慢。所以我们通常使用 ContDownLatch 对需要获取的数据进行并行处理，效果非常不错，比如在 200ms 内返回对 50 个耗时 100ms 的下层接口的调用。

### JVM 优化

虽然对 JVM 进行优化，有时候会获得巨大的性能提升，但在 JVM 不发生问题时，我们一般不会想到它。原因就在于，相较于上面 5 层所达到的效果来说，它的优化效果有限。但在代码优化、并行优化、JVM 优化的过程中，JVM 的知识却起到了关键性的作用，是一些根本性的影响因素。

### 操作系统优化

操作系统优化是解决问题的杀手锏，比如像 HugePage、Luma、“CPU 亲和性”这种比较底层的优化。但就计算节点来说，对操作系统进行优化并不是很常见。运维在背后会做一些诸如文件句柄的调整、网络参数的修改，这对于我们来说就已经够用了。



## JVM 优化

因为 JVM 一直处在变化之中，所以一些参数的配置并不总是有效的！！！

有时候加入一个参数，“感觉上”运行速度加快了，但通过 `-XX:+PrintFlagsFinal` 来查看，却发现这个参数默认就是这样：

比如 `UseAdaptiveSizePolicy`。**因此，在不同的 JVM 版本上，不同的垃圾回收器上，要先看一下这个参数默认是什么，不要轻信他人的建议。**

```shell
java -XX:+PrintFlagsFinal -XX:+UseG1GC 2>&1 | grep UseAdaptiveSizePolicy
```

### 内存区域大小

### 内存调优

### 垃圾回收器优化

### 其他参数优化

### 存疑优化

### GC 日志

### 故障排查

==**有需求才需要优化，不要为了优化而优化。**==

一般来说，上面提到 JVM 参数，基本能够保证应用安全，如果想要更进一步、更专业的性能提升，就没有什么通用的法则了。

打印详细的 GCLog，能够帮助了解到底是在哪一步骤发生了问题，然后才能对症下药。使用 `gceasy.io` 这样的线上工具，能够方便的分析到结果，但==**一些偏门的 JVM 参数修改，还是需要进行详细的验证。**==

一次或者多次模拟性的压力测试是必要的，能够提前发现这些优化点！！！

==**JVM 故障涉及到内存问题和计算问题，其中内存问题占多数。**==除了程序计数器，JVM 内存里划分每一个区域，都有溢出的可能：

- 最常见的就是堆溢出。**使用 jmap 可以 dump 一份内存，然后使用 MAT 工具进行具体原因的分析；**
- 对堆外内存的排查需要较高的技术水平。当发现进程占用的内存资源比使用 Xmx 设置得要多，不要忘这一环。

使用 `jstack` 可以获取 JVM 的执行栈，并且能够看到线程的一些阻塞状态，这部分可以使用 `arthas` 进行瞬时态的获取，定位到瞬时故障。

另外，一个完善的监控系统能够快速定位问题，包括操作系统的监控、JVM 的监控等。



**代码、JVM 优化和故障排查是一个持续优化的过程，只有更优、没有最优。如何在有限的项目时间内，最高效的完成工作，才是所需要的。**



## 总结

JVM 的优化效果是有限的，但它是理论的基础，代码优化和参数优化都需要它的指导。同时，有非常多的工具能够定位到问题。

偏门的优化参数可能有效，但不总是有效。实际上，从 CMS 到 G1，再到 ZGC，关于 GC 优化的配置参数也越来越少，协助排查问题的工具却越来越多。在大多数场景下，JVM 已经能够达到开箱即用的高性能效果，这是一个虚拟机所追求的最终目标。
