---
title: 抽象工厂模式：统一不同代码风格下代码级别
author:
  name: superhsc
  link: https://github.com/happymaya
date: 2018-02-01 20:45:00 +0800
categories: [Design Pattern, creational]
tags:  [设计模式, Design Pattern, Abstract factory, 抽象工厂模式, 对象创建型模式]
math: true
mermaid: true
---

在 GoF 的 《设计模式》一书中，工厂模式被分为三种：

1. 简单工厂
2. 工厂方法
3. 抽象工厂

其中，在书中作者将简单工厂模式看作是工厂方法模式的一种特例。

在实际工作中，用的比较多的是**工厂方法模式**和**抽象工厂模式**这两类**。**
下面先总结一下抽象工厂模式。

> **抽象工厂模式真正的重点和难点在于：如何找到正确的抽象。虽然抽象工厂模式很容易实现，但更重要的是意识到-“正确的抽象往往都很简单，也很底层”。比如：**
> - **数据库的增删查改操作，**
> - **日志的 debug、info、warn、error 级别，**
> - **JVM 内存模型，等等。**
> 
抽象工厂模式想要告诉不只是在写代码时随便建个抽象类就够了，而是当对一类功能进行抽象分析时有没有找到足够简单而又正确的抽象
{: .prompt-danger }


## 模式原理分析

抽象工厂模式的定义：提供了一个用于创建相关对象或对象族的接口，而不需要指定其具体类

显然，上面的定义是给使用者说的。因为从使用者的角度来看，他有时可能只关心某一个抽象的大类，例如，当去租车时，对店员说：“想要租一辆小型轿车”，但具体品牌和型号并不在意。但是站在创建者的角度看，他需要关注的是如何找到这个正确的抽象大类，就好比在前面的租车场景中，你需要从普通的汽车消费者变成汽车厂厂长一样，必须关注最后具体的型号该怎么落地。

因此，当在创建抽象工厂模式的时候，最终还是会涉及指定具体的实现类。

由此可见，抽象工厂模式的定义只是说了抽象工厂模式应该朝着分析共性规律的方向走，而具体操作时需要仔细分析具体实现类应该怎么实现才可以。

下面是抽象工厂模式原始的 UML 图：
![](/assets/post-img/design-patterns/abstract-factory.png#crop=0&crop=0&crop=1&crop=1&id=jJiRI&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

在上面的 UML 图中，能看出抽象工厂模式中包含了四个关键节点：

1. 抽象工厂
2. 抽象产品（通用的一类对象或接口）
3. 具体工厂
4. 具体产品（继承通用对象或接口后扩展特有属性）

为了更好的理解这四个角色，常常使用家具厂来类比。

比如说，抽象工厂生产的抽象产品是椅子、桌子、沙发一类的家具，那具体工厂可能就在生产具体的产品：椅子设计成现代简约风格或欧洲宫廷风格，使用的材质有木质或铝制，等等。本质上椅子的特性没有发生重大改变，但在外观上，不同的具体工厂生产的椅子尺寸、材质、外观各不相同。

其中最为关键的角色并不是抽象工厂本身，而是抽象产品。抽象产品的好坏才是直接决定了抽象工厂和具体工厂能否发挥最大作用的关键所在。这也是多次提到的“找到正确的抽象很重要”的原因。

明白了上诉道理，下面是 UML 图的代码实现，会发现思路特别清晰：

## 使用场景分析

实际工作中，抽象工厂模式在现实中有很多的应用。

比如，一个应用程序中支持多个操作系统时，就会用到抽象工厂模式这样的机制，需要为

## 使用抽象工厂模式的原因

使用抽象工厂模式的原因主要有一下三点：

1. 对于不同产品系列有比较多共性特征时，使用抽象工厂 模式，有助于提升组件的复用性。
2. 当需要提升代码的扩展性并降低维护成本时，把对象的创建和使用过程分开，能够有效地将代码统一到一个级别上。
3. 解决跨平台带来的兼容性问题。

## 优缺点

抽象工厂模式的优点，我总结为以下五点：

1. 符合开闭原则。当需要添加新的工厂类，只用新继承一个类，不用修改抽象工厂和其他具体类。
2. 保证同一工厂生成的产品符合预期。抽象工厂定义了统一的抽象产品功能，只要是继承了这个抽象工厂，本质的抽象产品功能是不会发生改变的。
3. 使用的和创建的代码进行解耦。在具体的代码实现中，使用者只用关心如何使用具体的功能，而不再需要关心这个对象的创建过程。这样使得对象与对象之间的耦合关系变得单一，降低了过多应用带来耦合风险。
4. 单一职责原则。由于将产品的实现代码放到同一层级里，并继承同一个抽象工厂类，所以说，即便具体的代码风格有所不同，也不影响最终提供功能的统一性，使得代码的可维护性大大提高。
5. 容易扩展（增加新的产品系列）。因为有了抽象工厂作为参考模板，那么再新增的具体工厂时非常容易，不需要修改其他具体工厂，并且各自的工厂可以朝着自己的演化方向发展。

当然，抽象工厂也有一些缺点。主要有以下三点：

1. 增加代码量。抽象工厂模式很好的进行了职责分离，同时也增加了更多的类文件和代码，使得开发时间长。并且随着子类越来越多，当一个抽象工厂需要改动时，影响的代码范围会很大。
2. 增加学习成本。抽象工厂模式是自顶向下的设计，在最开始就找到正确的抽象是一件非常困难的事情，这就需要大量的实践，并不断总结归纳。
3. 变更产品的结构困难。抽象工厂模式最大的缺点在于，一旦定义了某种产品结构后，要想修改就得修改所有的具体工厂和抽象工厂。

## 5 总结

抽象工厂模式的使用和创建很简单。

这个模式的重点和难点在于抓住抽象工厂模式的本质——找到正确的抽象，只有这样，才能更好的发挥抽象工厂模式的作用。当没有找到正确的抽象产品，不要着急使用抽象工厂模式，如果只是想要封装对象创建过程，使用工厂模式绰绰有余。

## 参考

- [设计模式](https://refactoringguru.cn/design-patterns)
- [图说](https://design-patterns.readthedocs.io/zh_CN/latest/)
