<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="面向对象原则：SOLID" /><meta name="author" content="superhsc" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="说到面向对象编程，有一个原则几乎每个程序员都知道，那就是 SOLID 原则。" /><meta property="og:description" content="说到面向对象编程，有一个原则几乎每个程序员都知道，那就是 SOLID 原则。" /><link rel="canonical" href="/posts/solid/" /><meta property="og:url" content="/posts/solid/" /><meta property="og:site_name" content="ThinkerWalker" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-04-09T09:30:20+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="面向对象原则：SOLID" /><meta name="twitter:site" content="@happymaya" /><meta name="twitter:creator" content="@superhsc" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"superhsc"},"dateModified":"2022-07-23T19:54:23+00:00","datePublished":"2022-04-09T09:30:20+00:00","description":"说到面向对象编程，有一个原则几乎每个程序员都知道，那就是 SOLID 原则。","headline":"面向对象原则：SOLID","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/solid/"},"url":"/posts/solid/"}</script><title>面向对象原则：SOLID | ThinkerWalker</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="ThinkerWalker"><meta name="application-name" content="ThinkerWalker"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" https://images.happymaya.cn/assert/avatar/logo.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">ThinkerWalker</a></div><div class="site-subtitle font-italic">日拱一卒 功不唐捐</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/happymaya" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/happymaya" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['haoshichuan','foxmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>面向对象原则：SOLID</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>面向对象原则：SOLID</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/happymaya">superhsc</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" data-ts="1649496620" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-04-09 </em> </span> <span> 更新于 <em class="timeago" data-ts="1658606063" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-07-24 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4846 字"> <em>26 分钟</em>阅读</span></div></div></div><div class="post-content"><p>说到面向对象编程，有一个原则几乎每个程序员都知道，那就是 SOLID 原则。</p><p>关于它的资料介绍也非常丰富，实践例子也很多。但实际上很有可能把 SOLID 原则都用错了，并且还无意识地一直在滥用它。之所以这么说，有两个方面：</p><ol><li>很多时候都将每一个原则分开使用，易造成过度解读。比如，在使用接口隔离原则时容易只关心接口，忽略不同实现，或者不关心接口之间的关系以及和整体系统之间的关系；<li>因为 SOLID 总是能让你无意识地将简单问题复杂化。比如，明明只需要写一个一次性同步数据的方法，然后写完即扔，有一天突然想到 SOLID 原则，于是又搞出来十几个多余的类。有了锤子，总是容易想去找钉子，殊不知有时就完全不需要锤子，只需要一把小刀即可解决问题。</ol><h1 id="五大设计原则">五大设计原则</h1><p>2000 年，Robert C. Martin 在他的《设计原理和设计模式》这一论文中首次提出 SOLID 原则的概念。而后，在过去 20 年中，这 5 条原则彻底改变了面向对象编程的世界，改变了我们编写软件的方式。 <strong>SOLID 原则的核心理念是帮助我们构建可维护和可扩展的软件</strong>。因为随着软件规模的扩大，一个人维护所有的代码越来越困难，这时就需要更多的人来维护代码，而多人协作的关键在于相互通信与协作，恰好 SOLID 原则提供了这样一个框架。 <strong>“SOILD”是由五大原则的英文首字母拼写而成，具体对应情况如下。</strong></p><ul><li>S（Single Responsibility Principle，简称 SRP）：单一职责原则，意思是对象应该仅具有一种单一的功能。<li>O（Open–Closed Principle，简称 OCP）：开闭原则，也就是程序对于扩展开放，对于修改封闭。<li>L（Liskov Substitution Principle，简称 LSP）：里氏替换原则，程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的。<li>I（Interface Segregation Principle，简称 ISP）：接口隔离原则，多个特定客户端接口要好于一个宽泛用途的接口。<li>D（Dependency Inversion Principle，简称 DIP）：依赖反转原则，该原则认为一个方法应该遵从“依赖于抽象而不是一个实例”。</ul><h2 id="单一职责原则srp"><span class="mr-2">单一职责原则（SRP）</span><a href="#单一职责原则srp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>单一职责原则（SRP）的原意是：<strong>对一个类而言，应该仅有一个引起它变化的原因。</strong></p><p>对此，通常更容易这么来理解：</p><ul><li>只有一个类或方法；<li>写好就不能修改的类或方法；<li>一个接口对应唯一一个实现。 上面这些理解不能说完全错，但是只抓住了单一职责原则（SRP）本质上重要的两点中的一点——<strong>单一</strong>，而忘记了另一个也很重要的点——<strong>职责</strong>。“职责”可以定义为“<strong>变化的原因”</strong>。三种理解方式不够准确原因如下：<li>职责不一定只有一个类或方法，还可能有多个类或方法，比如，上传文件是单一职责，而上传方法、增删改查 URL 方法、校验方法都服务于上传文件。<li>不能修改的类或方法本质上有很多影响因素，比如，代码长时间没有维护、设计时没有预留扩展接口，等等。<li>一个接口对应一个实现并不能说职责是单一的，因为一个接口中可能会存在没有划分清楚的职责。</ul><p>一个简单例子，假设有一个书籍类，保存书籍的名称、作者、内容，提供文字修订服务和查询服务，代码如下：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">cn.happymaya.ndp.principle.solid</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">author</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">text</span><span class="o">;</span>
    
    <span class="c1">// Omit constructor, getter and setters</span>
    
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">replaceWordInText</span><span class="o">(</span><span class="nc">String</span> <span class="n">world</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">text</span><span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="n">world</span><span class="o">,</span> <span class="n">text</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isWoldInText</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">text</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
    <span class="o">}</span> 
<span class="o">}</span>

</pre></table></code></div></div><p>整体服务运行良好。但是，有人说只是保存书的信息，不提供打印和阅读功能，岂不是很浪费资源。于是，立即加了打印和阅读的服务，如下所示：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="c1">//...</span>

    <span class="c1">//打印服务</span>
    <span class="kt">void</span> <span class="nf">printText</span><span class="o">(){</span>
        <span class="c1">//具体实现</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">getToRead</span><span class="o">(){</span>
        <span class="c1">//具体实现</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>到此，很容易发现，当打印服务需要针对不同的客服端进行适配时，书籍类就需要多次反复地进行修改，那么不同的类实例需要修改的地方就会越来越多，系统明显变得更加脆弱，同时也违反了 SRP。 所以说，理解 SRP 时，一定要抓住一个重点：<strong>职责是否具有唯一性</strong>。当有多个动机来改变一个类时，那么职责就多于一个，也就违反了 SRP。</p><h2 id="开闭原则ocp"><span class="mr-2">开闭原则（OCP）</span><a href="#开闭原则ocp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>开闭原则最初是由 Bertrand Meyer 在 20 世纪 80 年代提出的，被称为“面向对象设计中的最重要原理”。</p><p>开闭原则是指软件组件（类、方法、模块等）应该对扩展开发，对修改关闭。这就意味着当<strong>你在设计或修改程序代码时，应该尽量去扩展原有程序，而不是修改原有程序</strong>。</p><p>在我看来，<strong>开闭原则更像是一个框架的设计原则，而不是具体的业务编码技巧</strong>。因为在实际业务编码实现中，需求变化总是快于技术更新，直接修改业务代码的时间成本有时会比扩展的时间成本低很多，所以说，在非常细节的业务编码实现中，只扩展而不修改原始的代码几乎很难做到，反倒是在框架、类库或架构设计中常常更容易实现开闭原则。即便强行在编码实现中这样做，也会导致过多的冗余类产生，并导致最终系统整体调用关系复杂。</p><p>同样，用一个简单的例子来帮助理解开闭原则。如果基于 Spring JDBC 写不同 DataSource 进行读写分离的代码，就会对开闭原则有一个大致了解。具体代码如下：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="kd">extends</span> <span class="nc">AbstractDataSource</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">readDataSourceSize</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Connection</span> <span class="nf">getConnection</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">,</span> <span class="nc">String</span> <span class="n">password</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">SQLException</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">determineTargetDataSource</span><span class="o">().</span><span class="na">getConnection</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">)</span> <span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="nc">DataSource</span> <span class="nf">determineTargetDataSource</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">determineCurrentLookupKey</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">readDataSourceSize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 读库做负载均衡(从库)</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">loadBalance</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 写库使用主库</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">getResolveMasterDataSource</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">DataSource</span> <span class="nf">loadBalance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">DataSource</span> <span class="nf">getResolveMasterDataSource</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="kt">boolean</span> <span class="nf">determineCurrentLookupKey</span><span class="o">();</span>
<span class="o">}</span>

</pre></table></code></div></div><p>上面这段代码的大致意思是说：</p><ul><li>通过继承 AbstractDataSource 类，可以重新构造不同的 DataSource，以达到读库使用从库（做负载均衡）、写库使用主库的目的。这里虽然不能修改 Spring JDBC 的代码，但是可以通过扩展来实现更复杂的场景。</ul><p>这就是开闭原则的一种具体体现，很多时候总是会使用各种不同的工具和框架，不可能做到所有工具的自行开发，这时通过开闭原则就能进行很多的扩展与改进，而不需要重复造轮子。</p><h2 id="里氏替换原则lsp"><span class="mr-2">里氏替换原则（LSP）</span><a href="#里氏替换原则lsp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>里氏替换原则（LSP）这个名字看上去虽然有点奇怪，但是在面向对象编程中，它却是使用频率非常高的一个原则。 <strong>里氏替换原则（LSP）的原意是：子类应该能够完全替换掉它的基类。换句话说，在进行代码设计时，应该尽量保持子类和父类方法行为的一致性</strong>。这样做的好处在于，即便是扩展子类，也不会丢失父类的特性。 同时，<strong>里氏替换原则（LSP）也是针对接口编程的最佳实践原则之一</strong>，因为某一个接口定义的功能不改变，那么就可以使用很多不同算法的代码来替换同一个接口的功能。 比如，Spring 中提供的自定义属性编辑器，可以解析 HTTP 请求参数中的自定义格式进行绑定并转换为格式输出。只要遵循基类（PropertyEditorSupport）的约束定义，就能为某种数据类型注册一个属性编辑器。我们先定义一个类 DefineFormat，具体代码如下：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefineFormat</span><span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">rawStingFormat</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">uid</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">toAppCode</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">fromAppCode</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">Sting</span> <span class="n">timestamp</span><span class="o">;</span>

    <span class="c1">// 省略构造函数和get, set方法</span>

<span class="o">}</span>

</pre></table></code></div></div><p>然后，创建一个 Restful API 接口，用于输入自定义的请求 URL。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nd">@GetMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"/api/{d-format}"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">DefineFormat</span> <span class="nf">parseDefineFormat</span><span class="o">(</span>
    <span class="nd">@PathVariable</span><span class="o">(</span><span class="s">"d-format"</span><span class="o">)</span> <span class="nc">DefineFormat</span> <span class="n">defineFormat</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">defineFormat</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>接下来，创建 DefineFormatEditor，实现输入自定义字符串，返回自定义格式 json 数据。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefineFormatEditor</span> <span class="kd">extends</span> <span class="nc">PropertyEditorSupport</span> <span class="o">{</span>

    <span class="cm">/**
     * setAsText（） 用于将 String转换为另一个对象
     * @param text
     * @throws IllegalArgumentException
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAsText</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalArgumentException</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="n">text</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">setValue</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">DefineFormat</span> <span class="n">df</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DefineFormat</span><span class="o">();</span>
            <span class="n">df</span><span class="o">.</span><span class="na">setRawStingFormat</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>

            <span class="nc">String</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">spilt</span><span class="o">(</span><span class="s">"-"</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">4</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">df</span><span class="o">.</span><span class="na">setUid</span><span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
                <span class="n">df</span><span class="o">.</span><span class="na">setToAppCode</span><span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
                <span class="n">df</span><span class="o">.</span><span class="na">setFromAppCode</span><span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="mi">2</span><span class="o">]);</span>
                <span class="n">df</span><span class="o">.</span><span class="na">setTimestamp</span><span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="mi">3</span><span class="o">]);</span>
                <span class="n">setValue</span><span class="o">(</span><span class="n">df</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">setValue</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="cm">/**
     * 将对象序列化为 Strin g时，将调用getAsText（）方法
     * @return
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getAsText</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">DefineFormat</span> <span class="n">defineFormat</span><span class="o">=</span> <span class="o">(</span><span class="nc">DefineFormat</span><span class="o">)</span> <span class="n">getValue</span><span class="o">();</span>
        <span class="k">return</span> <span class="kc">null</span> <span class="o">==</span> <span class="n">defineFormat</span> <span class="o">?</span> <span class="s">""</span> <span class="o">:</span> <span class="n">defineFormat</span><span class="o">.</span><span class="na">getRawStingFormat</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>最后，输入 <code class="language-plaintext highlighter-rouge">url：/api/dlewgvi8we-toapp-fromapp-zzzzzzz</code>，返回响应。</p><div class="language-json highlighter-rouge"><div class="code-header"> <span data-label-text="JSON"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="p">{</span><span class="w">
  </span><span class="s2">"rawStingFormat:"</span><span class="err">dlewgvi</span><span class="mi">8</span><span class="err">we-toapp-fromapp-zzzzzz</span><span class="s2">",
  "</span><span class="err">uid:</span><span class="s2">"dlewgvi8we"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"toAppCode"</span><span class="p">:</span><span class="s2">"toapp"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"fromAppCode"</span><span class="p">:</span><span class="s2">"fromapp"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"message"</span><span class="p">:</span><span class="s2">"zzzzzzz"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></table></code></div></div><p>到此你会发现，使用<strong>里氏替换原则（LSP）的本质就是通过继承实现多态行为</strong>，这在面向对象编程中是非常重要的一个技巧，对于提高代码的扩展性是很有帮助的。</p><h2 id="接口隔离原则isp"><span class="mr-2">接口隔离原则（ISP）</span><a href="#接口隔离原则isp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>如果说单一职责原则（SRP）是适用于<strong>类</strong>的设计原则，那么接口隔离原则（ISP）就是适合<strong>接口</strong>的设计原则。 接口隔离原则（ISP）的原意是：<strong>不应该强迫用户依赖于他们不用的方法</strong>。什么情况下会造成“被强迫”呢？答案就是：当你在接口中有多余的定义时。比如下面代码中的接口定义：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ICRUD</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>

    <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>

    <span class="kt">void</span> <span class="nf">delete</span><span class="o">();</span>

    <span class="no">T</span> <span class="nf">query</span><span class="o">();</span>

    <span class="kt">void</span> <span class="nf">sync</span><span class="o">();</span>

<span class="o">}</span>

</pre></table></code></div></div><p>增删改查是应用最多的方法定义之一，但是你发现上面这段代码中的问题没？ 虽然我们定义的五个方法职责没有重合，但是其中有一个方法对于很多人来说，可能就是低频的方法，那就是同步（sync()）。这样显然没有做到接口的隔离，只是在一个接口中做了方法隔离，当你使用 ICRUD 接口时就会被强迫实现 sync() 方法。其实，正确的做法应该是将 sync() 方法分离出来，如下所示：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ICRUD</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">delete</span><span class="o">();</span>
    <span class="no">T</span> <span class="nf">query</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ISync</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">sync</span><span class="o">()</span><span class="err">；</span>
<span class="o">}</span>
</pre></table></code></div></div><p>这样代码就变得清晰了很多，将增删改查放在一起、同步放在一起，这才算得上实现了接口的隔离。换句话说，<strong>好的接口隔离不是只考虑一个接口中方法的隔离，还应该多考虑整体系统中的职责</strong>。 实际上，<strong>在应用接口隔离原则（ISP）时同样需要注意职责的单一度，</strong>而不能简单地认为只要定义的方法间没有重叠就算是隔离了。</p><h2 id="依赖反转原则dip"><span class="mr-2">依赖反转原则（DIP）</span><a href="#依赖反转原则dip" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>依赖反转原则（DIP）的原意是：</p><ul><li>高层模块不应该依赖底层模块，二者都应该依赖于抽象；<li>抽象不应该依赖于细节，细节应该依赖于抽象。</ul><p>简单来说，就是应该在编程时<strong>寻找好的抽象。这里的抽象不是简单地指 Java 中的 interface，而是指可以创建出固定却能够描述一组任意个可能行为的抽象体</strong>。 而好的抽象就是指<strong>具备一些共性规律并能经得起实践检验的抽象</strong>。比如，关系型数据库（RDMS）就是对数据存储与查询的一种正确抽象。再比如，我们非常熟悉的 JDBC 协议就是一种对数据库增删改查使用的正确抽象，还有我们课程后面模块要讲的设计模式也是某种场景下的正确抽象。 当然，好的抽象并不容易找到，更多的时候你还是得做很多定制化的开发。 总之，依赖反转原则（DIP）给的启示是：<strong>要尽量通过寻找好的抽象来解决大量重复工作的效率问题</strong>。</p><h1 id="五个原则之间的关系">五个原则之间的关系</h1><p>虽然 SOLID 原则在面向对象编程中应用广泛，但是千万不要死记硬背。 在我看来，SOLID 原则之间其实是有一定联系的，搞清楚这些联系，不仅能帮助你理解记忆 SOLID 原则，而且还能更好地应用它们。SOLID 五大原则之间的关系图，如下所示： <img data-src="https://images.happymaya.cn/assert/design-patterns/1657702293135-ea3bf356-3309-43bf-9d01-c739a78e8433.png#clientId=u9b961bcc-7541-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=385&amp;id=u363509a9&amp;margin=%5Bobject%20Object%5D&amp;name=%E5%9B%BE%E7%89%87.png&amp;originHeight=385&amp;originWidth=516&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=131960&amp;status=done&amp;style=none&amp;taskId=u627545ef-c2bd-4142-871c-3ef046755e0&amp;title=&amp;width=516" alt="图片.png" data-proofer-ignore></p><ol><li><strong>开闭原则是 SOLID 原则追求的最终目标</strong>。因为修改代码非常容易引入 Bug，即便是很小的改动都有可能引起未知的 Bug。而一旦系统因为 Bug 出现故障，担责的一定是我们。没有人愿意担责，所以，我们都更喜欢写新代码而不是修改旧代码。除此之外，在设计之初就尽量以实现开闭原则为目标，它能为你在未来的实际开发中提供更高的代码扩展性。不过，这里需要注意一下，开闭原则不是封闭原则，千万不要把遵守开闭原则当作必要条件，如果代码需要适应现实的需求变化而必须要修改的话，那么这时就应该违反原则。当然尽量还是要做到开闭；<li><strong>单一职责原则是重要的基础原则，它帮助实现了里氏替换原则、接口隔离原则和开闭原则</strong>。只要仔细分析各个原则的含义就能发现，它们都涉及了两个关键动作：分离和替换。那么是逻辑揉在一起、接口定义模糊的代码容易分离和替换，还是职责单一、接口抽象清晰的代码容易分离和替换呢？答案很明显是后者。之所以说单一职责原则是基础，就是因为要想实现代码的灵活扩展性需要更容易理解的模块。而职责单一的模块，更容易被组合起来用于更大的职责，也能进行快速替换和修改；<li><strong>依赖反转原则是一种指导原则，同样是用来分离和替换代码的</strong>。只不过它作用在更高层次、更广的范围内，因为它太重要了。</ol><h1 id="总结">总结</h1><p>SOLID 原则是面向对象编程中非常重要的指导原则：</p><ul><li>使用 SOLID 越多，代码可重用性变得越来越高的同时，代码逻辑却也相应地变得越复杂。之所以会变得复杂，是因为 SOLID 原则太过于重视分离与灵活替换，这就意味着可能需要创建很多单一的类和方法，再通过接口把它们连接起来，这样反而容易让模块和模块之间的调用关系变得更错综复杂，增加了整体的复杂性。这显然违背了 KISS 原则；<li><strong>当想要兼顾 KISS 原则和 SOLID 原则时，最简单的办法就是控制接口的数量</strong>。尽量抽象某一个职责下的通用接口类（可以有多个实现类），而不是搞出很多的一个接口只对应一个实现类的模块，这看上去是在依赖抽象，实际上还是在依赖单个的实现。</ul><p>SOLID 原则本质上就是为了<strong>在不修改原有模块的情况下有更好的扩展功能，也就是实现开闭原则，</strong>但是要想真正做到，一定不能忽略一个隐含的前提条件，那就是<strong>在设计时就要提前考虑模块的扩展性</strong>。如果一个系统在设计时就只有一个大模块，所有的功能都揉在里面，这样即便你想要应用 SOLID 原则，也是做不到的。 另外，在应用 SOLID 原则时一定要结合五个原则综合考虑，并结合实际业务进行合理取舍。千万不要在某个原则上过度解读，而误认为要满足所有 SOLID 原则才算是应用了 SOLID 原则。</p><p>关于 Robert C. Martin 的书：</p><ul class="task-list"><li class="task-list-item" hide-bullet><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" /><strong>《代码整洁之道》</strong><li class="task-list-item" hide-bullet><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" /><strong>《代码整洁之道 程序员的职业素养》，</strong>《代码整洁之道》姊妹篇，讲解要成为真正专业程序员要具备什么样的态度，需要遵循什么样的原则，需要采取什么样的行动<li class="task-list-item" hide-bullet><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" /><strong>《重构：改善既有代码的设计（第2版）》，</strong>揭示了重构的过程，解释了重构的原理和最佳实践方式，并给出了何时以及何地应该开始挖掘代码以求改善。给出了 60 多个可行的重构，每个重构都介绍了一种经过验证的代码变换手法的动机和技术。提出的重构准则可以一次一小步修改代码，减少开发过程中的风险</ul><p><a href="https://docs.spring.io/spring-framework/docs/4.2.x/spring-framework-reference/html/index.html">Spring docs</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/design-pattern/'>Design Pattern</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/solid/" class="post-tag no-text-decoration" >SOLID</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=面向对象原则：SOLID - ThinkerWalker&amp;url=/posts/solid/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=面向对象原则：SOLID - ThinkerWalker&amp;u=/posts/solid/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=/posts/solid/&amp;text=面向对象原则：SOLID - ThinkerWalker" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/use-spring-security-to-build-a-user-authentication-system/">Spring Security 的配置体系</a><li><a href="/posts/spring-data-jpa-test/">利用单元测试和集成测试</a><li><a href="/posts/query-annotation/">Spring Data JPA - @Query</a><li><a href="/posts/defining-query-methods/">Spring Data JPA - Defining Query Methods 的命名语法与参数</a><li><a href="/posts/cache-redis-02/">Redis 的数据类型</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/thread/">thread</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/design-pattern/">Design Pattern</a> <a class="post-tag" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a> <a class="post-tag" href="/tags/architecture-design/">Architecture Design</a> <a class="post-tag" href="/tags/backend-system/">Backend System</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/spring-security/">Spring Security</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/cache/">Cache</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/combined-thinking/"><div class="card-body"> <em class="timeago small" data-ts="1649475020" > 2022-04-09 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>组合思维：Unix 哲学启示</h3><div class="text-muted small"><p> Unix 操作系统诞生于 20 世纪 60 年代，经过几十年的发展，技术日臻成熟。 在这个过程中，Unix 独特的设计哲学和美学也深深地吸引了一大批技术开发人员，他们在维护和使用 Unix 的同时，Unix 也影响了他们的思考方式和看待世界的角度。 简单来说，Unix 哲学是一套基于 Unix 操作系统顶级开发者们的经验所提出的软件开发的准则和理念。Unix 哲学并不是正统的计算机科学理...</p></div></div></a></div><div class="card"> <a href="/posts/engineering-thinking/"><div class="card-body"> <em class="timeago small" data-ts="1649475020" > 2022-04-09 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>工程思维：用软件工程方法解决开发难题</h3><div class="text-muted small"><p> 在工作中，有时候会遇到下面一些情形： 团队辛辛苦苦做出的软件产品，却被客户云淡风轻地评价一句：“这不是我想要的。” 在新的项目中，作为系统的主要设计者，采用了很多新技术，却发现团队成员的技术水平参差不齐，项目进度不断延期； 每次一到季度或年度总结的时候，明明做了很多项目，付出了很多努力，但是被问到这些项目具体取得了哪些收益、对业务有哪些提升时，却顿时语塞。 要解决这些问题，...</p></div></div></a></div><div class="card"> <a href="/posts/reversal-principle/"><div class="card-body"> <em class="timeago small" data-ts="1649475020" > 2022-04-09 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>反转原则：减少代码间相互影响</h3><div class="text-muted small"><p> SOLID 五大设计原则中，其中有一个原则，可能用得很熟练，但是说到概念却又容易跟其他原则混淆的，那就是依赖反转原则（Dependence Inversion Principle，简称 DIP）。 在实际的研发工作中，可能会遇到以下场景： 一个平台系统，需要接入各种各样的业务系统，而这些业务系统都有自己的账号体系，平台需要兼容这些系统的账号体系，于是代码中出现了大量依赖于各种账号体系...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/reversal-principle/" class="btn btn-outline-primary" prompt="上一篇"><p>反转原则：减少代码间相互影响</p></a> <a href="/posts/duty-principle/" class="btn btn-outline-primary" prompt="下一篇"><p>职责原则：在代码设计中实现职责分离</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/happymaya">superhsc</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/thread/">thread</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/design-pattern/">Design Pattern</a> <a class="post-tag" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a> <a class="post-tag" href="/tags/architecture-design/">Architecture Design</a> <a class="post-tag" href="/tags/backend-system/">Backend System</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/spring-security/">Spring Security</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/cache/">Cache</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
