<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="TCP 的稳定性：滑动窗口和流速控制" /><meta name="author" content="superhsc" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="TCP 利用发送字节数和接收字节数，这个二元组的唯一性保证顺序。本文研究下保证顺序的具体算法，以及如何在保证顺序的基础上，同时追求更高的吞吐量。我认为，这部分知识也是 TCP 协议中最有趣的部分 —— TCP 的滑动窗口算法。" /><meta property="og:description" content="TCP 利用发送字节数和接收字节数，这个二元组的唯一性保证顺序。本文研究下保证顺序的具体算法，以及如何在保证顺序的基础上，同时追求更高的吞吐量。我认为，这部分知识也是 TCP 协议中最有趣的部分 —— TCP 的滑动窗口算法。" /><link rel="canonical" href="/posts/tcp-stability-04/" /><meta property="og:url" content="/posts/tcp-stability-04/" /><meta property="og:site_name" content="ThinkerWalker" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-07-04T14:32:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="TCP 的稳定性：滑动窗口和流速控制" /><meta name="twitter:site" content="@happymaya" /><meta name="twitter:creator" content="@superhsc" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"superhsc"},"dateModified":"2018-07-04T14:32:00+00:00","datePublished":"2018-07-04T14:32:00+00:00","description":"TCP 利用发送字节数和接收字节数，这个二元组的唯一性保证顺序。本文研究下保证顺序的具体算法，以及如何在保证顺序的基础上，同时追求更高的吞吐量。我认为，这部分知识也是 TCP 协议中最有趣的部分 —— TCP 的滑动窗口算法。","headline":"TCP 的稳定性：滑动窗口和流速控制","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/tcp-stability-04/"},"url":"/posts/tcp-stability-04/"}</script><title>TCP 的稳定性：滑动窗口和流速控制 | ThinkerWalker</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="ThinkerWalker"><meta name="application-name" content="ThinkerWalker"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" https://images.happymaya.cn/assert/avatar/logo.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">ThinkerWalker</a></div><div class="site-subtitle font-italic">日拱一卒 功不唐捐</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/happymaya" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/happymaya" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['haoshichuan','foxmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>TCP 的稳定性：滑动窗口和流速控制</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>TCP 的稳定性：滑动窗口和流速控制</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/happymaya">superhsc</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" data-ts="1530714720" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2018-07-04 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2770 字"> <em>15 分钟</em>阅读</span></div></div></div><div class="post-content"><p>TCP 利用发送字节数和接收字节数，这个二元组的唯一性保证顺序。本文研究下保证顺序的具体算法，以及如何在保证顺序的基础上，同时追求更高的吞吐量。我认为，这部分知识也是 TCP 协议中最有趣的部分 —— TCP 的滑动窗口算法。</p><p>TCP 作为一个传输层协议，最核心的能力是传输。传输需要保证可靠性，还需要控制流速，这两个核心能力均由<strong>滑动窗口提供</strong>。而滑动窗口中解决的问题，是在今后的工作中可以长期使用的，比如设计一个分布式的 RPC 框架、实现一个消息队列或者分布式的文件系统等。</p><h2 id="请求响应模型"><span class="mr-2">请求/响应模型</span><a href="#请求响应模型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>TCP 中每个发送的请求都需要响应。如果一个请求没有收到响应，发送方就会认为这次发送出现了故障，会触发重发。</p><p>大体的模型，与下图很像。但是如果完全和下图一样，每一个请求收到响应之后，再发送下一个请求，吞吐量会很低。因为这样的设计，会产生网络的空闲时间，说白了，就是浪费带宽。带宽没有用满，意味着可以同时发送更多的请求，接收更多的响应。</p><p><img data-src="https://images.happymaya.cn/assert/network/network-0401.png" alt="TCP 请求/响应模型（吞吐量低）" data-proofer-ignore></p><p>一种改进的方式，就是让发送方有请求就发送出去，而不是等待响应。通过这样的处理方式，发送的数据连在了一起，响应的数据也连在了一起，吞吐量就提升了。</p><p><img data-src="https://images.happymaya.cn/assert/network/network-0402.png" alt="" data-proofer-ignore></p><p>但是如果可以同时发送的数据真的非常多呢？比如成百上千个 TCP 段都需要发送，这个时候带宽可能会不足。像下图这样，很多个数据封包都需要发送，该如何处理呢？</p><p><img data-src="https://images.happymaya.cn/assert/network/network-0403.png" alt="network-0402" data-proofer-ignore></p><h2 id="排队queuing"><span class="mr-2">排队（Queuing）</span><a href="#排队queuing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>在这种情况下，通常会考虑排队（Queuing）机制。</p><p><img data-src="https://images.happymaya.cn/assert/network/network-0405.png" alt="" data-proofer-ignore></p><p>考虑这样一个模型，如上图所示，在 TCP 层实现一个队列。新元素从队列的一端（左侧）排队，作为一个未发送的数据封包。开始发送的数据封包，从队列的右侧离开。</p><h3 id="缺点"><span class="mr-2">缺点</span><a href="#缺点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>这样做就需要多个队列，我们要将未发送的数据从队列中取出，加入发送中的队列。然后再将发送中的数据，收到 ACK 的部分取出，放入已接收的队列。而发送中的封包，何时收到 ACK 是一件不确定的事情，这样使用队列似乎也有一定的问题。</p><h2 id="滑动窗口sliding-window"><span class="mr-2">滑动窗口（Sliding Window）</span><a href="#滑动窗口sliding-window" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>在上面的模型当中，之所以觉得算法不好设计，是因为用错了数据结构。有个说法叫作如果程序写复杂了，那就是写错了。这里其实应该用一种叫作<strong>滑动窗口的数据结构</strong>去实现。</p><p><img data-src="https://images.happymaya.cn/assert/network/network-0406.png" alt="" data-proofer-ignore></p><p>如上图所示：</p><ul><li>浅绿色代表发送了，但是没有收到 ACK 的段；<li>白色代表没有发送的段；<li>紫色代表暂时不能发送的段</ul><p>下面重新设计一下不同类型封包的顺序，将已发送的数据放到最左边，发送中的数据放到中间，未发送的数据放到右边。</p><p>假设最多同时发送 5 个封包，也就是窗口大小 = 5。窗口中的数据被同时发送出去，然后等待 ACK。如果一个封包 ACK 到达，就将它标记为已接收（深绿色）。如下图所示，有两个封包的 ACK 到达，因此标记为绿色。</p><p><img data-src="https://images.happymaya.cn/assert/network/network-0407.png" alt="" data-proofer-ignore></p><p>这个时候滑动窗口可以向右滑动，如下图所示：</p><p><img data-src="https://images.happymaya.cn/assert/network/network-0408.png" alt="" data-proofer-ignore></p><h2 id="重传"><span class="mr-2">重传</span><a href="#重传" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>如果发送过程中，部分数据没能收到 ACK 会怎样呢？这就可能发生<strong>重传。</strong></p><p>如果发生下图这样的情况，段 4 迟迟没有收到 ACK。</p><p><img data-src="https://images.happymaya.cn/assert/network/network-0409.png" alt="" data-proofer-ignore></p><p>这个时候滑动窗口只能右移一个位置，如下图所示：</p><p><img data-src="https://images.happymaya.cn/assert/network/network-0410.png" alt="" data-proofer-ignore></p><p>在这个过程中，如果后来段 4 重传成功（接收到 ACK），那么窗口就会继续右移。如果段 4 发送失败，还是没能收到 ACK，那么接收方也会抛弃段 5、段 6、段 7。这样从段 4 开始之后的数据都需要重发。</p><h2 id="快速重传"><span class="mr-2">快速重传</span><a href="#快速重传" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>在 TCP 协议中，如果接收方想丢弃某个段，可以选择不发 ACK。发送端超时后，会重发这个 TCP 段。而有时候，接收方希望催促发送方尽快补发某个 TCP 段，这个时候可以使用快速重传能力。</p><p>例如段 1、段 2、段 4 到了，但是段 3 没有到。 接收方可以发送多次段 3 的 ACK。如果发送方收到多个段 3 的 ACK，就会重发段 3。这个机制称为快速重传。这和超时重发不同，是一种催促的机制。</p><p>为了不让发送方误以为段 3 已经收到了，在快速重传的情况下，接收方即便收到发来的段 4，依然会发段 3 的 ACK（不发段 4 的 ACK），直到发送方把段 3 重传。</p><h3 id="思考窗口大小的单位是"><span class="mr-2">思考：窗口大小的单位是？</span><a href="#思考窗口大小的单位是" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>窗口大小的单位是多少呢？在上面所有的图片中，窗口大小是 TCP 段的数量。<strong>实际操作中，每个 TCP 段的大小不同，限制数量会让接收方的缓冲区不好操作，因此实际操作中窗口大小单位是字节数。</strong></p><h2 id="流速控制"><span class="mr-2">流速控制</span><a href="#流速控制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><strong>发送、接收窗口的大小可以用来控制 TCP 协议的流速。</strong>窗口越大，同时可以发送、接收的数据就越多，支持的吞吐量也就越大。当然，窗口越大，如果数据发生错误，损失也就越大，因为需要重传越多的数据。</p><p>举个例子：用 RTT 表示 Round Trip Time，就是消息一去一回的时间。</p><p>假设 RTT = 1ms，带宽是 1mb/s。如果窗口大小为 1kb，那么 1ms 可以发送一个 1kb 的数据（含 TCP 头），1s 就可以发送 1mb 的数据，刚好可以将带宽用满。如果 RTT 再慢一些，比如 RTT = 10ms，那么这样的设计就只能用完 1/10 的带宽。 当然你可以提高窗口大小提高吞吐量，但是实际的模型会比这个复杂，因为还存在重传、快速重传、丢包等因素。</p><p>而实际操作中，也不可以真的把带宽用完，所以会使用折中的方案，在延迟、丢包率、吞吐量中进行选择，毕竟鱼和熊掌不可兼得。</p><h2 id="总结"><span class="mr-2">总结</span><a href="#总结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>为了提高传输速率，TCP 协议选择将多个段同时发送，为了让这些段不至于被接收方拒绝服务，在发送前，双方要协商好发送的速率。但是不可能完全确定网速，所以协商的方式，就变成确定窗口大小。</p><p>有了窗口，发送方利用滑动窗口算法发送消息；接收方构造缓冲区接收消息，并给发送方 ACK。滑动窗口的实现只需要数组和少量的指针即可，是一个非常高效的算法。像这种算法，简单又实用，比如求一个数组中最大的连续 k 项和，就可以使用滑动窗口算法。如果你对这个问题感兴趣，不妨用你最熟悉的语言尝试解决一下。</p><p>滑动窗口和流速控制是怎么回事：</p><ul><li><p>滑动窗口是 TCP 协议控制可靠性的核心。发送方将数据拆包，变成多个分组。然后将数据放入一个拥有滑动窗口的数组，依次发出，仍然遵循先入先出（FIFO）的顺序，但是窗口中的分组会一次性发送。窗口中序号最小的分组如果收到 ACK，窗口就会发生滑动；如果最小序号的分组长时间没有收到 ACK，就会触发整个窗口的数据重新发送。</p><li><p>另一方面，在多次传输中，网络的平均延迟往往是相对固定的，这样 TCP 协议可以通过双方协商窗口大小控制流速。补充下，上面我们说的分组和 TCP 段是一个意思。</p></ul><p>既然发送方有窗口，那么接收方也需要有窗口吗：</p><ul><li><p>接收方收到发送方的每个数据分组（或者称为 TCP Segment），接收方肯定需要缓存。举例来说，如果发送方发送了：1, 2, 3, 4。 那么接收方可能收到的一种情况是：1，4，3。注意，没有收到 2 的原因可能是延迟、丢包等。这个时候，接收方有两种选择。</p><ul><li><p><strong>选择一：什么都不做</strong>（这样分组 2 的 ACK 就不会发送给发送方，发送方发现没有收到 2 的 ACK，过一段时间就有可能重发 2,3,4,5）。 当然具体设计还需要探讨，比如不重发整个分组，只重发已发送没有收到 ACK 的分组。这种方法的缺陷是<strong>性能太差</strong>，重发了整个分组（或部分）。因此我们可以考虑另一种选择。</p><li><p><strong>选择二</strong>：如果<strong>重发一个窗口，或部分窗口</strong>，问题就不会太大了。虽然增加了网络开销，但是毕竟有进步（1 进步了，不会再重发）。</p><p>性能方面最大的开销是<strong>等待超时的时间</strong>，就是发送方要等到超时时间才重发窗口，这样操作性能太差。因此，TCP 协议有一个<strong>快速重传</strong>的机制——接收方发现接收到了 1，但是没有接收到 2，那么马上发送 3 个分组 2 的 ACK 给到发送方，这样发送方收到多个 ACK，就知道接收方没有收到 2，于是马上重发 2。</p></ul><p>无论是上面哪种方案，接收方也维护一个滑动窗口，是一个不错的选择。接收窗口的状态，可以和发送窗口的状态相互对应了。</p></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/internal-power/'>Internal Power</a>, <a href='/categories/network/'>Network</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/udp/" class="post-tag no-text-decoration" >UDP</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=TCP 的稳定性：滑动窗口和流速控制 - ThinkerWalker&amp;url=/posts/tcp-stability-04/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=TCP 的稳定性：滑动窗口和流速控制 - ThinkerWalker&amp;u=/posts/tcp-stability-04/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=/posts/tcp-stability-04/&amp;text=TCP 的稳定性：滑动窗口和流速控制 - ThinkerWalker" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/use-spring-security-to-build-a-user-authentication-system/">Spring Security 的配置体系</a><li><a href="/posts/spring-data-jpa-test/">利用单元测试和集成测试</a><li><a href="/posts/query-annotation/">Spring Data JPA - @Query</a><li><a href="/posts/defining-query-methods/">Spring Data JPA - Defining Query Methods 的命名语法与参数</a><li><a href="/posts/cache-redis-02/">Redis 的数据类型</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/thread/">thread</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/design-pattern/">Design Pattern</a> <a class="post-tag" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a> <a class="post-tag" href="/tags/architecture-design/">Architecture Design</a> <a class="post-tag" href="/tags/backend-system/">Backend System</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/spring-security/">Spring Security</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/cache/">Cache</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Honeycomb-mobile-network-01/"><div class="card-body"> <em class="timeago small" data-ts="1530450720" > 2018-07-01 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>漫游互联网：什么是蜂窝移动网络</h3><div class="text-muted small"><p> 从 DataReportal 2021 年 1 月的统计数据来看，全球 78 亿人口中，有 52 亿手机用户，46 亿互联网用户。 能够接入网络的设备越来越多，体量越来越大，这样一个庞大的世界是如何被构造出来的？ 思科（Cisco，世界 500 强通信设备提供商）在一篇报告中曾指出，2016 年年底全球 IP 流量超过 1 个 Zettabyte，也就是 1021 个字节，相当于一万亿 ...</p></div></div></a></div><div class="card"> <a href="/posts/tcp-02/"><div class="card-body"> <em class="timeago small" data-ts="1530534720" > 2018-07-02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>传输层协议 TCP：TCP 为什么握手是 3 次、挥手是 4 次？</h3><div class="text-muted small"><p> TCP 和 UDP 是今天应用最广泛的传输层协议，拥有最核心的垄断地位。 今天互联网的整个传输层，几乎都是基于这两个协议打造的。无论是应用开发、框架设计选型、做底层和优化，还是定位线上问题，只要碰到网络，就逃不开 TCP 协议相关的知识。 在面试中 TCP 一直是一个高频考察内容，外加 TCP 关联的知识比较多，因此面试题五花八门。其中一道高频面试题：TCP 协议为什么握手是 3 次，挥...</p></div></div></a></div><div class="card"> <a href="/posts/tcp-packet-03/"><div class="card-body"> <em class="timeago small" data-ts="1530621120" > 2018-07-03 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>TCP 的封包格式：TCP 为什么要粘包和拆包</h3><div class="text-muted small"><p> 从稳定性角度深挖 TCP 协议的运作机制。 如今，大半个互联网都建立在 TCP 协议之上，使用的 HTTP 协议、消息队列、存储、缓存，都需要用到 TCP 协议—— 这是因为 TCP 协议提供了可靠性。 简单来说，可靠性就是让数据无损送达。但若是考虑到成本，就会变得非常复杂 —— 因为还需要尽可能地提升吞吐量、降低延迟、减少丢包率。 TCP 协议具有很强的实用性，而可靠性又是 TCP ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/tcp-packet-03/" class="btn btn-outline-primary" prompt="上一篇"><p>TCP 的封包格式：TCP 为什么要粘包和拆包</p></a> <a href="/posts/udp-05/" class="btn btn-outline-primary" prompt="下一篇"><p>UDP 协议：TCP 协议和 UDP 协议的优势和劣势</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/happymaya">superhsc</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/thread/">thread</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/design-pattern/">Design Pattern</a> <a class="post-tag" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a> <a class="post-tag" href="/tags/architecture-design/">Architecture Design</a> <a class="post-tag" href="/tags/backend-system/">Backend System</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/spring-security/">Spring Security</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/cache/">Cache</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
