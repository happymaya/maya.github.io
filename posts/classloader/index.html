<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="类的加载机制" /><meta name="author" content="superhsc" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="类的加载机制" /><meta property="og:description" content="类的加载机制" /><link rel="canonical" href="/posts/classloader/" /><meta property="og:url" content="/posts/classloader/" /><meta property="og:site_name" content="ThinkerWalker" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-08-03T14:23:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="类的加载机制" /><meta name="twitter:site" content="@happymaya" /><meta name="twitter:creator" content="@superhsc" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"superhsc"},"dateModified":"2021-08-03T14:23:00+00:00","datePublished":"2021-08-03T14:23:00+00:00","description":"类的加载机制","headline":"类的加载机制","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/classloader/"},"url":"/posts/classloader/"}</script><title>类的加载机制 | ThinkerWalker</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="ThinkerWalker"><meta name="application-name" content="ThinkerWalker"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" https://images.happymaya.cn/assert/avatar/logo.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">ThinkerWalker</a></div><div class="site-subtitle font-italic">日拱一卒 功不唐捐</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/happymaya" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/happymaya" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['haoshichuan','foxmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>类的加载机制</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>类的加载机制</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/happymaya">superhsc</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" data-ts="1628000580" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2021-08-03 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4547 字"> <em>25 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="类的加载机制">类的加载机制</h1><p>JVM 的类加载机制和 Java 的类加载机制类似，但 JVM 的类加载过程稍有些复杂。</p><p>JVM 通过加载 .class 文件，能够将其中的字节码解析成操作系统机器码。那这些文件是怎么加载进来的呢？又有哪些约定？</p><h2 id="类加载过程"><span class="mr-2">类加载过程</span><a href="#类加载过程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>并不是说，把一个文件修改成 .class 后缀，就能够被 JVM 识别。类的加载过程非常复杂，主要有这几个过程：</p><ul><li>加载；<li>验证；<li>准备；<li>解析；<li>初始化</ul><p><img data-src="https://images.happymaya.cn/assert/java/jvm/jvm-03-01.png" alt="类加载过程" data-proofer-ignore></p><p>如图所示。<strong>大多数情况下，类会按照图中给出的顺序进行加载。</strong></p><h3 id="加载"><span class="mr-2">加载</span><a href="#加载" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>主要作用是<strong>将外部的 .class 文件，加载到 Java 的方法区内</strong>（想一下内存区域图）。</p><p>加载阶段主要是找到并加载类的二进制数据，比如从 jar 包里或者 war 包里找到它们。</p><h3 id="验证"><span class="mr-2">验证</span><a href="#验证" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>肯定不能任何 .class 文件都能加载，那样太不安全了，容易受到恶意代码的攻击。</p><p>验证阶段在虚拟机整个类加载过程中占了很大一部分，不符合规范的将抛出 <code class="language-plaintext highlighter-rouge">java.lang.VerifyError</code> 错误。</p><p>像一些低版本的 JVM，是无法加载一些高版本的类库的，就是在这个阶段完成的。</p><h3 id="准备"><span class="mr-2">准备</span><a href="#准备" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>从这部分开始，将为一些类变量分配内存，并将其初始化为默认值。此时，实例对象还没有分配内存，所以这些动作是在方法区上进行的。</p><p>一道面试题。下面两段代码，A 将会输出 0，而 B 将无法通过编译：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">cn.happymaya.three</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">a</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">a</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>之所以有这样的不同，这是因为<strong>局部变量不像类变量那样存在准备阶段。</strong></p><p>类变量有两次赋初始值的过程：</p><ul><li>一次在准备阶段，赋予初始值（也可以是指定值）；<li>另外一次在初始化阶段，赋予程序员定义的值。</ul><p>因此，即使程序员没有为类变量赋值也没有关系，它仍然有一个默认的初始值。但局部变量就不一样了，如果没有给它赋初始值，是不能使用的。</p><h3 id="解析"><span class="mr-2">解析</span><a href="#解析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>解析在类加载中是非常非常重要的一环，是将<strong>符号引用替换为直接引用的过程</strong>（非常的拗口，其实理解起来也非常的简单）。</p><ul><li>符号引用，是一种定义，可以是任何字面上的含义；<li>直接引用，是直接指向目标的指针、相对偏移量。</ul><p>直接引用的对象都存在于内存中，可以把通讯录里的女友手机号码，类比为符号引用，把面对面和你吃饭的人，类比为直接引用。</p><p><strong>解析阶段负责把整个类激活，串成一个可以找到彼此的网，</strong>过程不可谓不重要。</p><p>这个阶段做的工作呢大体可以分为：</p><ul><li>类或接口的解析<li>类方法解析<li>接口方法解析<li>字段解析</ul><p>几个经常发生的异常，就与这个阶段有关：</p><ul><li><p><code class="language-plaintext highlighter-rouge">java.lang.NoSuchFieldError</code>，根据继承关系从下往上，找不到相关字段时的报错。</p><li><p><code class="language-plaintext highlighter-rouge">java.lang.IllegalAccessError</code>，字段或者方法，访问权限不具备时的错误。</p><li><p><code class="language-plaintext highlighter-rouge">java.lang.NoSuchMethodError</code>，找不到相关方法时的错误。</p></ul><p>解析过程保证了<strong>相互引用的完整性，把继承与组合推进到运行时</strong>。</p><h3 id="初始化"><span class="mr-2">初始化</span><a href="#初始化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>如果前面的流程一切顺利的话，接下来该初始化成员变量了，到了这一步，才真正开始执行一些字节码。</p><p>一道面试题：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"there is static block"</span><span class="o">);</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>结果是 1 0。a 和 b 唯一的区别就是它们的 static 代码块的位置。</p><p>这就引出一个规则：<strong>static 语句块，只能访问到定义在 static 语句块之前的变量。</strong>所以下面的代码是无法通过编译的。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="o">{</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
<span class="kd">static</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</pre></table></code></div></div><p>第二个规则：<strong>JVM 会保证在子类的初始化方法执行之前，父类的初始化方法已经执行完毕。</strong></p><p>所以，JVM 第一个被执行的类初始化方法一定是 <code class="language-plaintext highlighter-rouge">java.lang.Object</code>。<strong>也意味着父类中定义的 static 语句块要优先于子类的。</strong></p><h4 id="clinit与init"><span class="mr-2"><code class="language-plaintext highlighter-rouge"><span class="mr-2">&lt;clinit&gt;</code>与<code class="language-plaintext highlighter-rouge"><span class="mr-2">&lt;init&gt;</code></span><a href="#clinit与init" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>不得不再说一个面试题：<clinit> 方法和 <init> 方法有什么区别（明白类的初始化和对象的初始化之间的差别）？</init></clinit></p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">cn.happymaya.three</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"i'm class D : static block"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">D</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"i'm class D : No args constructor"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">E</span> <span class="kd">extends</span> <span class="no">D</span><span class="o">{</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"i'm class E : static block : class D is My Father"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">E</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"i'm class E : No args constructor : class D is My Father"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">D</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="no">E</span><span class="o">();</span>
        <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="no">E</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>输出结果如下：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">i</span><span class="err">'</span><span class="n">m</span> <span class="kd">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="kd">static</span> <span class="n">block</span>
<span class="n">i</span><span class="err">'</span><span class="n">m</span> <span class="kd">class</span> <span class="nc">E</span> <span class="o">:</span> <span class="kd">static</span> <span class="n">block</span> <span class="o">:</span> <span class="kd">class</span> <span class="nc">D</span> <span class="n">is</span> <span class="nc">My</span> <span class="nc">Father</span>
<span class="n">i</span><span class="err">'</span><span class="n">m</span> <span class="kd">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="nc">No</span> <span class="n">args</span> <span class="n">constructor</span>
<span class="n">i</span><span class="err">'</span><span class="n">m</span> <span class="kd">class</span> <span class="nc">E</span> <span class="o">:</span> <span class="nc">No</span> <span class="n">args</span> <span class="n">constructor</span> <span class="o">:</span> <span class="kd">class</span> <span class="nc">D</span> <span class="n">is</span> <span class="nc">My</span> <span class="nc">Father</span>
<span class="n">i</span><span class="err">'</span><span class="n">m</span> <span class="kd">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="nc">No</span> <span class="n">args</span> <span class="n">constructor</span>
<span class="n">i</span><span class="err">'</span><span class="n">m</span> <span class="kd">class</span> <span class="nc">E</span> <span class="o">:</span> <span class="nc">No</span> <span class="n">args</span> <span class="n">constructor</span> <span class="o">:</span> <span class="kd">class</span> <span class="nc">D</span> <span class="n">is</span> <span class="nc">My</span> <span class="nc">Father</span>
</pre></table></code></div></div><p>看下这张图：</p><p><img data-src="https://images.happymaya.cn/assert/java/jvm/jvm-03-02.jpeg" alt="类加载过程" data-proofer-ignore></p><p>static 字段和 static 代码块，是属于类的，在类加载的初始化阶段就已经被执行。</p><p><strong>类信息</strong>会被存放在<strong>方法区</strong>，在同一个类加载器下，这些信息有一份就够了，所以<strong>上面的 static 代码块只会执行一次</strong>，它对应的是 <code class="language-plaintext highlighter-rouge">&lt;clinit&gt;</code> 方法。</p><p>而对象初始化就不一样了。通常，在 new 一个新对象的时候，都会调用它的构造方法，就是 <code class="language-plaintext highlighter-rouge">&lt;init&gt;</code>，用来初始化对象的属性。<strong>每次新建对象的时候，都会执行。</strong></p><h2 id="类加载器"><span class="mr-2">类加载器</span><a href="#类加载器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>整个类加载过程任务非常繁重，虽然这活儿很累，但总得有人干。</p><p>类加载器做的就是上面 5 个步骤的事。</p><p>如果在项目代码里，写一个 java.lang 的包，然后改写 String 类的一些行为，编译后，发现并不能生效。<strong>JRE 的类当然不能轻易被覆盖，否则会被别有用心的人利用，这就太危险了。</strong></p><p>类加载器有着<strong>严格的等级制度的保证这个过程的安全性</strong>！！！</p><h3 id="几个类加载器"><span class="mr-2">几个类加载器</span><a href="#几个类加载器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>Bootstrap ClassLoader，根加载器，加载器中的大 Boss，任何类的加载行为，都要经它过问，C++ 编写的，随着 JVM 启动。</p><p>它的作用是加载核心类库，也就是 rt.jar、resources.jar、charsets.jar 等。当然这些 jar 包的路径是可以指定的，-Xbootclasspath 参数可以完成指定操作。</p><li><p><strong>Extention ClassLoader，</strong>扩展类加载器，是个 Java 类，继承自 URLClassLoader。</p><p>主要用于加载 lib/ext 目录下的 jar 包和 .class 文件。同样的，通过系统变量 java.ext.dirs 可以指定这个目录。</p><li><p><strong>App ClassLoader，</strong>这是我们写 Java 类的默认加载器，也叫作 <strong>System ClassLoader</strong>。</p><p>一般用来加载 classpath 下的其他所有 jar 包和 .class 文件，我们写的代码，会首先尝试使用这个类加载器进行加载。</p><li><p><strong>Custom ClassLoader，</strong>自定义加载器。</p><p>支持一些个性化的扩展功能。</p></ul><h3 id="双亲委派机制"><span class="mr-2">双亲委派机制</span><a href="#双亲委派机制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>双亲委派机制的意思是：<strong>除了顶层的启动类加载器以外，其余的类加载器，在加载之前，都会委派给它的父加载器进行加载。这样一层层向上传递，直到祖先们都无法胜任，它才会真正的加载。</strong></p><p>打个比方。有一个家族，都是一些听话的孩子。孙子想要买一块棒棒糖，最终都要经过爷爷过问，如果力所能及，爷爷就直接帮孙子买了。</p><p>有个问题：“类加载的双亲委派机制，双亲在哪里？明明都是单亲？”</p><p>用一张图来理解：可以看到，<strong>除了启动类加载器，每一个加载器都有一个 parent，并没有所谓的双亲。但是由于翻译的问题，这个叫法已经非常普遍了，一定要注意背后的差别</strong>。</p><p><img data-src="https://images.happymaya.cn/assert/java/jvm/jvm-03-03.jpeg" alt="" data-proofer-ignore></p><p>翻阅 JDK 代码的 ClassLoader#loadClass 方法，来看一下具体的加载过程：</p><ul><li>首先，使用 parent 尝试进行类加载；<li>然后，parent 失败后才轮到自己。</ul><p>这个方法是可以被覆盖的，也就是双亲委派机制不一定生效。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">loadClass</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ClassNotFoundException</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">loadClass</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">protected</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">loadClass</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">resolve</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ClassNotFoundException</span> <span class="o">{</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">getClassLoadingLock</span><span class="o">(</span><span class="n">name</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// First, check if the class has already been loaded</span>
        <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">findLoadedClass</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">t0</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 首先使用 parent 尝试进行类加载</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">findBootstrapClassOrNull</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// ClassNotFoundException thrown if class not found</span>
                <span class="c1">// from the non-null parent class loader</span>
            <span class="o">}</span>
            <span class="c1">// parent 失败后才轮到自己</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If still not found, then invoke findClass in order</span>
                <span class="c1">// to find the class.</span>
                <span class="kt">long</span> <span class="n">t1</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">findClass</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
                <span class="c1">// this is the defining class loader; record the stats</span>
                <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">PerfCounter</span><span class="o">.</span><span class="na">getParentDelegationTime</span><span class="o">().</span><span class="na">addTime</span><span class="o">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="o">);</span>
                <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">PerfCounter</span><span class="o">.</span><span class="na">getFindClassTime</span><span class="o">().</span><span class="na">addElapsedTimeFrom</span><span class="o">(</span><span class="n">t1</span><span class="o">);</span>
                <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">PerfCounter</span><span class="o">.</span><span class="na">getFindClasses</span><span class="o">().</span><span class="na">increment</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">resolve</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">resolveClass</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>注意到，这个方法是可以被覆盖的，也就是双亲委派机制并不一定生效。</p><p>这个模型的好处在于：</p><ul><li>Java 类有了一种优先级的层次划分关系。比如 Object 类，这个毫无疑问应该交给最上层的加载器进行加载，即使是覆盖了它，最终也是由系统默认的加载器进行加载的。<li>如果没有双亲委派模型，就会出现很多个不同的 Object 类，应用程序会一片混乱。</ul><h3 id="一些自定义加载器"><span class="mr-2">一些自定义加载器</span><a href="#一些自定义加载器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>打破双亲委派机制的一些案例。为了支持一些自定义加载类多功能的需求，Java 设计者作出了一些妥协。</p><h4 id="案例一tomcat"><span class="mr-2">案例一：tomcat</span><a href="#案例一tomcat" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><strong>tomcat 通过 war 包进行应用的发布，它其实是违反了双亲委派机制原则的。</strong></p><p>tomcat 类加载器的层次结构：</p><p><img data-src="https://images.happymaya.cn/assert/java/jvm/jvm-03-05.png" alt="" data-proofer-ignore></p><p>对于一些<strong>需要加载的非基础类</strong>，由一个叫作 <strong>WebApp ClassLoader 的类加载器优先加载</strong>。等它加载不到的时候，再交给上层的 ClassLoader 进行加载。这个加载器<strong>用来隔绝不同应用的 .class 文件</strong>，比如两个应用，可能会依赖同一个第三方的不同版本，它们是相互没有影响的。</p><p>如何在同一个 JVM 里，运行着不兼容的两个版本，当然是需要自定义加载器才能完成的事。那么 tomcat 是怎么打破双亲委派机制的呢：看图中的 <strong>WebApp ClassLoader</strong>，它加载自己目录下的 .class 文件，并不会传递给父类的加载器。但是，它却可以使用 <strong>SharedClassLoader</strong> 所加载的类，实现了共享和分离的功能。</p><p>假设自己写一个 ArrayList，放在应用目录里，tomcat 依然不会加载。它<strong>只是自定义的加载器顺序不同，但对于顶层来说，还是一样的。</strong></p><h4 id="案例二spi"><span class="mr-2">案例二：SPI</span><a href="#案例二spi" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><strong>Java 中有一个 SPI 机制，全称是 Service Provider Interface，是 Java 提供的一套用来被第三方实现或者扩展的 API，它可以用来启用框架扩展和替换组件。</strong></p><p>拿常用的数据库驱动加载来说，在使用 JDBC 写程序之前，通常会调用下面这行代码，用于加载所需要的驱动类。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"com.mysql.cj.jdbc.Driver"</span><span class="o">)</span>
</pre></table></code></div></div><p>这只是一种初始化模式，通过 static 代码块显式地声明了驱动对象，然后把这些信息，保存到底层的一个 List 中。</p><p>但是删除了 Class.forName 这一行代码，也能加载到正确的驱动类，什么都不需要做，非常的神奇，它是怎么做到的呢</p><ul><li><p>翻开 MySQL 的驱动代码，发现了一个奇怪的文件。之所以能够发生这样神奇的事情，就是在这里实现的。</p><li><p>路径：<code class="language-plaintext highlighter-rouge">mysql-connector-java-8.0.15.jar!/META-INF/services/java.sql.Driver</code></p><li><p>里面的内容是：<code class="language-plaintext highlighter-rouge">com.mysql.cj.jdbc.Driver</code></p><li><p>通过在 META-INF/services 目录下，创建一个以接口全限定名为命名的文件（内容为实现类的全限定名），即可自动加载这一种实现，这就是 SPI。</p></ul><p>SPI 实际上是“<strong>基于接口的编程＋策略模式＋配置文件</strong>”组合实现的动态加载机制，主要使用 <strong>java.util.ServiceLoader</strong> 类进行动态装载。</p><p><img data-src="https://images.happymaya.cn/assert/java/jvm/jvm-03-06.jpg" alt="" data-proofer-ignore></p><p>这种方式，同样打破了双亲委派的机制。</p><ul><li>DriverManager 类和 ServiceLoader 类都是属于 rt.jar 的。它们的类加载器是 Bootstrap ClassLoader，也就是最上层的那个；<li>具体的数据库驱动，却属于业务代码，这个启动类加载器是无法加载的。这就比较尴尬了，虽然凡事都要祖先过问，但祖先没有能力去做这件事情，怎么办？<li>通过代码发现 Java 玩了个魔术，它把当前的类加载器，设置成了线程的上下文类加载器。那么，对于一个刚刚启动的应用程序来说，它当前的加载器是谁呢？也就是说，启动 main 方法的那个加载器，到底是哪一个？<li>继续跟踪代码，找到 Launcher 类，就是 jre 中用于启动入口函数 main 的类。在 Launcher 中找到以下代码；<li>到此为止，事情就比较明朗了，当前线程上下文的类加载器，是应用程序类加载器。使用它来加载第三方驱动，是没有什么问题的。</ul><h4 id="案例三osgi"><span class="mr-2">案例三：OSGI</span><a href="#案例三osgi" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>OSGI 曾经非常流行，Eclipse 就使用 OSGi 作为插件系统的基础。</p><p>OSGI 是服务平台的规范，旨在用于需要长运行时间、动态更新和对运行环境破坏最小的系统。</p><p>OSGI 规范定义了很多关于包生命周期，以及基础架构和绑定包的交互方式。这些规则，通过使用特殊 Java 类加载器来强制执行，比较霸道。</p><p>比如，在一般 Java 应用程序中，classpath 中的所有类都对所有其他类可见，这是毋庸置疑的。但是，OSGi 类加载器基于 OSGI 规范和每个绑定包的 manifest.mf 文件中指定的选项，来限制这些类的交互，这就让编程风格变得非常的怪异。不难想象，这种与直觉相违背的加载方式，肯定是由专用的类加载器来实现的。</p><p>随着 jigsaw 的发展（旨在为 Java SE 平台设计、实现一个标准的模块系统），个人认为，现在的 OSGI ，意义已经不是很大了。OSGI 是一个庞大的话题，你只需要知道，有这么一个复杂的东西，实现了模块化，每个模块可以独立安装、启动、停止、卸载，就可以了。</p><p>Java 的类加载器，可以玩出这么多花样。</p><h2 id="替换-jdk-的类"><span class="mr-2">替换 JDK 的类</span><a href="#替换-jdk-的类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>如何替换 JDK 中的类？</p><p>当 Java 的原生 API 不能满足需求时，比如修改 HashMap 类，就必须要使用到 <strong>Java 的 endorsed 技术</strong>。</p><ul><li>需要将自己的 HashMap 类，打包成一个 jar 包，然后放到<code class="language-plaintext highlighter-rouge">-Djava.endorsed.dirs</code> 指定的目录中。<li>注意类名和包名，应该和 JDK 自带的是一样的。但是，java.lang 包下面的类除外，因为这些都是特殊保护的。</ul><p><strong>因为双亲委派机制，无法直接在应用中替换 JDK 的原生类的。但是，有时候又不得不进行一下增强、替换，比如想要调试一段代码，或者比 Java 团队早发现了一个 Bug。所以，Java 提供了 endorsed 技术，用于替换这些类。这个目录下的 jar 包，会比 rt.jar 中的文件，优先级更高，可以被最先加载到。</strong></p><h2 id="总结"><span class="mr-2">总结</span><a href="#总结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>一个 Java 类的加载，经过了加载、验证、准备、解析、初始化几个过程，每一个过程都划清了各自负责的事情；<li>Java 自带的三个类加载器。main 方法的线程上下文加载器，其实是 <strong>Application ClassLoader</strong>；<li>一般情况下，类加载是遵循双亲委派机制的。这个双亲很有问题有很多打破这个规则的情况。类加载器通过开放的 API，让加载过程更加灵活；<li>无论是远程存储字节码，还是将字节码进行加密，这都是业务需求。要做这些，我们实现一个新的类加载器就可以了。</ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/java/'>Java</a>, <a href='/categories/jvm/'>JVM</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/jvm/" class="post-tag no-text-decoration" >JVM</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=类的加载机制 - ThinkerWalker&amp;url=/posts/classloader/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=类的加载机制 - ThinkerWalker&amp;u=/posts/classloader/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=/posts/classloader/&amp;text=类的加载机制 - ThinkerWalker" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/use-spring-security-to-build-a-user-authentication-system/">Spring Security 的配置体系</a><li><a href="/posts/spring-data-jpa-test/">利用单元测试和集成测试</a><li><a href="/posts/query-annotation/">Spring Data JPA - @Query</a><li><a href="/posts/defining-query-methods/">Spring Data JPA - Defining Query Methods 的命名语法与参数</a><li><a href="/posts/cache-redis-02/">Redis 的数据类型</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/thread/">thread</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/design-pattern/">Design Pattern</a> <a class="post-tag" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a> <a class="post-tag" href="/tags/architecture-design/">Architecture Design</a> <a class="post-tag" href="/tags/backend-system/">Backend System</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/spring-security/">Spring Security</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/cache/">Cache</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/jvm-memory/"><div class="card-body"> <em class="timeago small" data-ts="1627914180" > 2021-08-02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>JVM 内存管理</h3><div class="text-muted small"><p> 随着 Java 的发展，内存布局一直在调整之中。比如，Java 8 及之后的版本，彻底移除了持久代，而使用 Metaspace 来进行替代。这也表示着 -XX:PermSize 和 -XX:MaxPermSize 等参数调优，已经没有了意义。但大体上，比较重要的内存区域是固定的。 数据私有（线程相关） 程序计数器（Program counter regist...</p></div></div></a></div><div class="card"> <a href="/posts/gc-2-1/"><div class="card-body"> <em class="timeago small" data-ts="1627914180" > 2021-08-02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>垃圾回收 - 垃圾回收算法</h3><div class="text-muted small"><p> 之所以 Java 不用“手动管理”内存回收，代码写起来很顺畅。是因为 JVM 是有专门的线程在做这件事情。当内存空间达到一定条件时，会自动触发。这个过程就叫作 GC，负责 GC 的组件，就叫作垃圾回收器。 JVM 规范没有规定垃圾回收器怎么实现，它只需要保证不要把正在使用的对象给回收掉就可以。在现在的服务器环境中，经常被使用的垃圾回收器有 CMS 和 G1，但 JVM 还有其他几个常见的垃...</p></div></div></a></div><div class="card"> <a href="/posts/stackframe-bytecode/"><div class="card-body"> <em class="timeago small" data-ts="1628090580" > 2021-08-04 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>从栈帧看字节码在 JVM 中进行流转</h3><div class="text-muted small"><p> 怎么查看字节码文件？ 字节码文件长什么样子？ 对象初始化之后，具体的字节码又是怎么执行的？ 工具 javap javap 是 JDK 自带的反解析工具。它的作用是将 .class 字节码文件解析成可读的文件格式。 在使用 javap 时我一般会添加 -v 参数，尽量多打印一些信息。同时，我也会使用 -p 参数，打印一些私有的字段和方法。使用起来大概是这样： 1 ja...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/gc-2-1/" class="btn btn-outline-primary" prompt="上一篇"><p>垃圾回收 - 垃圾回收算法</p></a> <a href="/posts/stackframe-bytecode/" class="btn btn-outline-primary" prompt="下一篇"><p>从栈帧看字节码在 JVM 中进行流转</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/happymaya">superhsc</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/thread/">thread</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/design-pattern/">Design Pattern</a> <a class="post-tag" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a> <a class="post-tag" href="/tags/architecture-design/">Architecture Design</a> <a class="post-tag" href="/tags/backend-system/">Backend System</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/spring-security/">Spring Security</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/cache/">Cache</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
