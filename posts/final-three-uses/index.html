<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="final 的三种用法" /><meta name="author" content="superhsc" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="final 的作用" /><meta property="og:description" content="final 的作用" /><link rel="canonical" href="/posts/final-three-uses/" /><meta property="og:url" content="/posts/final-three-uses/" /><meta property="og:site_name" content="ThinkerWalker" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-10-28T15:33:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="final 的三种用法" /><meta name="twitter:site" content="@happymaya" /><meta name="twitter:creator" content="@superhsc" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"superhsc"},"dateModified":"2022-06-22T04:58:47+00:00","datePublished":"2019-10-28T15:33:00+00:00","description":"final 的作用","headline":"final 的三种用法","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/final-three-uses/"},"url":"/posts/final-three-uses/"}</script><title>final 的三种用法 | ThinkerWalker</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="ThinkerWalker"><meta name="application-name" content="ThinkerWalker"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" https://images.happymaya.cn/assert/avatar/logo.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">ThinkerWalker</a></div><div class="site-subtitle font-italic">日拱一卒 功不唐捐</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/happymaya" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/happymaya" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['haoshichuan','foxmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>final 的三种用法</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>final 的三种用法</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/happymaya">superhsc</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" data-ts="1572276780" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2019-10-28 </em> </span> <span> 更新于 <em class="timeago" data-ts="1655873927" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-06-22 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4814 字"> <em>26 分钟</em>阅读</span></div></div></div><div class="post-content"><h2 id="final-的作用"><span class="mr-2">final 的作用</span><a href="#final-的作用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>final 是 Java 中的一个关键字。</p><p>简单来说，final 的作用意味着“<strong>这是无法改变的</strong>”。</p><p>final 关键字一共有三种用法：</p><ul><li>修饰<strong>变量</strong>；<li>修饰<strong>方法</strong>；<li>修饰<strong>类</strong>。</ul><p>在修饰不同的地方时，<strong>效果</strong>、<strong>含义</strong>和<strong>侧重点</strong>也会有所不同。</p><h2 id="final-修饰变量"><span class="mr-2">final 修饰变量</span><a href="#final-修饰变量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="作用"><span class="mr-2">作用</span><a href="#作用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>意味着被修饰得变量<strong>一旦被赋值就不能被修改了</strong>，也就是说只能被赋值一次，直到天涯海角也不会“变心”。</p><p>如果尝试对一个已经赋值过 final 的变量再次赋值，就会报编译错误。</p><p>下面这段代码示例：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="cm">/**
 * &lt;h1&gt;final 的三种用法&lt;/h1&gt;
 * &lt;ol&gt;
 *     &lt;li&gt;修饰变量&lt;/li&gt;
 *     &lt;li&gt;修饰方法&lt;/li&gt;
 *     &lt;li&gt;修饰类&lt;/li&gt;
 * &lt;/ol&gt;
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreeUsesOfFinal</span> <span class="o">{</span>

    <span class="cm">/**
     * &lt;h2&gt;修饰变量&lt;/h2&gt;
     * &lt;p&gt;final 变量一旦被赋值，就不能被修改&lt;/p&gt;
     */</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">finalVar</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ThreeUsesOfFinal</span> <span class="n">threeUsesOfFinal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreeUsesOfFinal</span><span class="o">();</span>
        <span class="c1">// threeUsesOfFinal.finalVar = 9;  // 无法将值赋给 final 变量 'finalVar'</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>在这个例子中，有一个 final 修饰的 int，这个变量叫作 finalVar，然后在 main 函数中，新建了这个类的实例，并且尝试去修改它的值，此时会<strong>报编译错误</strong>，所以这体现了 final 修饰变量的一个最主要的作用：<strong>一旦被赋值就不能被修改了</strong>。</p><h3 id="目的"><span class="mr-2">目的</span><a href="#目的" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>使用 final 修饰变量，主要有两个目的：</p><ol><li><p><strong>设计角度</strong>。比如希望创建一个一旦被赋值就不能改变的量，那么就可以使用 final 关键字。就像<strong>声明常量的时候</strong>，通常都是带 final 的：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">YEAR</span> <span class="o">=</span> <span class="mi">2021</span><span class="o">;</span>
</pre></table></code></div></div><p>此时 YEAR 是固定写死的，为了防止它被修改，就给它加上了 final 关键字，这样可以让这个常量更加清晰，也更不容易出错。</p><li><p><strong>线程安全的角度</strong>。<strong>不可变</strong>的对象天生就是线程安全的，所以不需要额外进行同步等处理，这些开销是没有的。如果 final 修饰的是<strong>基本数据类型</strong>，那么它自然就具备了不可变这个性质，所以自动保证了线程安全，这样的话，未来去使用它也就非常放心了。</p></ol><p>这就是使用 final 去修饰变量的两个目的。</p><h3 id="赋值时机"><span class="mr-2">赋值时机</span><a href="#赋值时机" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>变量可以分为以下三种：</p><ul><li>成员变量，类中的非 static 修饰的属性；<li>静态变量，类中的被 static 修饰的属性；<li>局部变量，方法中的变量。</ul><p>这三种不同情况的变量，被 final 修饰后，赋值时机也各不相同。</p><h4 id="成员变量"><span class="mr-2">成员变量</span><a href="#成员变量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>成员变量指的是<strong>一个类中的非 static 属性</strong>。</p><p>对于这种成员变量而言，被 final 修饰后，有三种赋值时机（或者叫作赋值途径）。</p><ol><li>在声明变量的等号右边直接赋值，例如： ```java /**<ul><li><h1>final 的三种用法</h1><li><ol></ol><li><li>修饰变量<li><li>修饰方法<li><li>修饰类<li><p>&lt;/ol&gt; * */ public class ThreeUsesOfFinal {</p><p>/**</p><ul><li><h2>修饰变量</h2><li><p>final 变量一旦被赋值，就不能被修改</p><li><p>复制时机：</p><p>*/ public final int finalVar = 0;</p></ul><p>public static void main(String[] args) { ThreeUsesOfFinal threeUsesOfFinal = new ThreeUsesOfFinal(); // threeUsesOfFinal.finalVar = 9; // 无法将值赋给 final 变量 ‘finalVar’ } } ``` 在这个类中有 <code class="language-plaintext highlighter-rouge">private final int finalVar = 0</code> ，在声明变量的时候就已经赋值了。</p></ul><li>在构造函数中赋值，例如： ```java /**<ul><li><h1>final 的三种用法</h1><li><ol></ol><li><li>修饰变量<li><li>修饰方法<li><li>修饰类<li><p>&lt;/ol&gt; * */ public class ThreeUsesOfFinal { // 首先声明了变量，但是没有赋值 public final int finalVar2;</p><p>ThreeUsesOfFinal() { // 在本类的构造函数中，进行赋值 finalVar2 = 0; } }</p></ul><li>在类的构造代码块中赋值（不常用），例如： ```java /**<ul><li><h1>final 的三种用法</h1><li><ol></ol><li><li>修饰变量<li><li>修饰方法<li><li>修饰类<li><p>&lt;/ol&gt; * */ public class ThreeUsesOfFinal {</p><p>public final int finalVar3;</p><p>{ finalVar3 = 0; } }</p></ul></ol><p>​ 同样也声明了一个变量 private final int finalVar，且没有把它赋值， 然后在下面的一个由大括号括起来的类的构造代码块中，对变量进行 了赋值，这也是合理的赋值时机。</p><p>注意，三种赋值时机，<strong>必须从中挑一种来完成对 final 变量的赋值</strong>。</p><p>如果不是 final 的普通变量，当然可以不用在这三种情况下赋值，完全可以在其他的时机赋值；如果不准备使用这个变量，那么自始至终不赋值甚至也是可以的。</p><p>对于 final 修饰的成员变量而言，必须在三种情况中任选一种来进行赋值，而不能一种都不挑、完全不赋值，那是不行的，这是 final 语法所规定的。</p><p><strong>空白 final</strong></p><p>如果声明了 final 变量之后，并没有立刻在等号右侧对它赋值，这种情况就被称为“<strong>空白 final</strong>”。</p><p>这样做的好处：增加了 final 变量的灵活性，比如可以在构造函数中根据不同的情况，对 final 变量进行不同的赋值，这样的话，被 final 修饰的变量就不会变得死板，同时又能保证在赋值后保持不变。我们用下面这个代码来说明：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="cm">/**
 * &lt;h1&gt;空白 final 提供了灵活性&lt;/h1&gt;
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BlankFinal</span> <span class="o">{</span>
    
    <span class="c1">// 空白 final</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">a</span><span class="o">;</span>
    
    <span class="c1">// 不传参数，把 a 赋值为默认值 0</span>
    <span class="kd">public</span> <span class="nf">BlankFinal</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 穿参数，则把 a 赋值为传入的参数</span>
    <span class="kd">public</span> <span class="nf">BlankFinal</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>在这个代码中，有一个 private final 的 int 变量叫作 a，该类有两个构造函数：</p><ol><li>第一个构造函数是把 a 赋值为 0；<li>第二个构造函数是把 a 赋值为传进来的参数。 所以调用不同的构造函数，就会有不同的赋值情况。</ol><p>这样一来，利用这个规则，就可以根据业务去给 final 变量设计更灵活的赋值逻辑。</p><p><strong>利用空白 final 的一大好处，就是可以让这个 final 变量的值并不是说非常死板，不是绝对固定的，而是可以根据情况进行灵活的赋值，只不过一旦赋值后，就不能再更改了</strong>。</p><h4 id="静态变量"><span class="mr-2">静态变量</span><a href="#静态变量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>静态变量是类中的 static 属性，它被 final 修饰后，只有两种赋值时机。</p><p>第一种同样是在声明变量的等号右边直接赋值，例如：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cm">/**
 * &lt;h1&gt;final 的三种用法&lt;/h1&gt;
 * &lt;ol&gt;
 *     &lt;li&gt;修饰变量&lt;/li&gt;
 *     &lt;li&gt;修饰方法&lt;/li&gt;
 *     &lt;li&gt;修饰类&lt;/li&gt;
 * &lt;/ol&gt;
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreeUsesOfFinal</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

<span class="o">}</span>
</pre></table></code></div></div><p>第二种赋值时机就是它可以在一个静态的 static 初始代码块中赋值，这种用法不是很多，例如：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cm">/**
 * &lt;h1&gt;final 的三种用法&lt;/h1&gt;
 * &lt;ol&gt;
 *     &lt;li&gt;修饰变量&lt;/li&gt;
 *     &lt;li&gt;修饰方法&lt;/li&gt;
 *     &lt;li&gt;修饰类&lt;/li&gt;
 * &lt;/ol&gt;
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreeUsesOfFinal</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="o">{</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p>在这个类中有一个变量 private static final int a，然后有一个 static，接着是大括号，这是静态初始代码块的语法，在这里面我们对 a 进行了赋值，这种赋值时机也是允许的。以上就是静态 final 变量的两种赋值时机。</p><p>需要注意的是，不能用普通的非静态初始代码块来给静态的 final 变量赋值。同样有一点比较特殊的是，这个 <strong>static 的 final 变量不能在构造函数中进行赋值</strong>。</p><h4 id="局部变量"><span class="mr-2">局部变量</span><a href="#局部变量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>局部变量指的是方法中的变量，如果你把它修饰为了 final，它的含义依然是<strong>一旦赋值就不能改变</strong>。</p><p>但是它的赋值时机和前两种变量是不一样的，因为它是在方法中定义的，所以它没有构造函数，也同样不存在初始代码块，所以对应的这两种赋值时机就都不存在了。实际上，对于 final 的局部变量而言，它是不限定具体赋值时机的，只要求我们<strong>在使用之前必须对它进行赋值</strong>即可。</p><p>这个要求和方法中的非 final 变量的要求也是一样的，对于方法中的一个非 final 修饰的普通变量而言，它其实也是要求在使用这个变量之前对它赋值。我们来看下面这个代码的例子：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="cm">/**
 * 描述：     本地变量的赋值时机：使用前赋值即可
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LocalVarAssignment1</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">foo</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="c1">//等号右边直接赋值</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">LocalVarAssignment2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">foo</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">a</span><span class="o">;</span><span class="c1">//这是允许的，因为a没有被使用</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">LocalVarAssignment3</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">foo</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">a</span><span class="o">;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="c1">//使用前赋值</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>首先我们来看下第一个类，即 LocalVarAssignment1，然后在 foo() 方法中有一个 final 修饰的 int a，最后这里直接在等号右边赋值。</p><p>下面看第二个类，由于我们后期没有使用到这个 final 修饰的局部变量 a，所以这里实际上自始至终都没有对 a 进行赋值，即便它是 final 的，也可以对它不赋值，这种行为是语法所允许的。</p><p>第三种情况就是先创造出一个 final int a，并且不在等号右边对它进行赋值，然后在使用之前对 a 进行赋值，最后再使用它，这也是允许的。</p><p>总结一下，对于这种局部变量的 final 变量而言，它的赋值时机就是<strong>要求在使用之前进行赋值</strong>，否则使用一个未赋值的变量，自然会报错。</p><h3 id="特殊用法final-修饰参数"><span class="mr-2">特殊用法：final 修饰参数</span><a href="#特殊用法final-修饰参数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>关键字 final 还可以用于修饰方法中的参数。在方法的参数列表中是可以把参数声明为 final 的，这意味着<strong>我们没有办法在方法内部对这个参数进行修改</strong>。例如：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre>/**

 * 描述：     final参数

 */

public class FinalPara {

    public void withFinal(final int a) {

        System.out.println(a);//可以读取final参数的值

//        a = 9; //编译错误，不允许修改final参数的值

    }

}

</pre></table></code></div></div><p>在这个代码中有一个 withFinal 方法，而且这个方法的入参 a 是被 final 修饰的。接下来，我们首先把入参的 a 打印出来，这是允许的，意味着我们可以读取到它的值；但是接下来我们假设想在方法中对这个 a 进行修改，比如改成 a = 9，这就会报编译错误，因此不允许修改 final 参数的值。</p><p>以上我们就把 final 修饰变量的情况都讲完了，其核心可以用一句话总结：<strong>一旦被赋值就不能被修改了</strong>。</p><h2 id="final-修饰方法"><span class="mr-2">final 修饰方法</span><a href="#final-修饰方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>选择用 final 修饰方法的原因之一是为了<strong>提高效率</strong>。</p><p>因为在早期的 Java 版本中，会把 final 方法转为内嵌调用，可以消除方法调用的开销，以提高程序的运行效率。</p><p>不过在后期的 Java 版本中，JVM 会对此自动进行优化，所以不需要程序员去使用 final 修饰方法来进行这些优化了，即便使用也不会带来性能上的提升。</p><p>目前使用 final 去修饰方法的唯一原因，就是想把这个方法锁定，意味着任何继承类都不能修改这个方法的含义，也就是说，被 final 修饰的方法<strong>不可以被重写</strong>，不能被 override。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="cm">/**
 *  final 修饰的方法不允许被重写
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FinalMethod</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">drink</span><span class="o">()</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">(){}</span>

<span class="o">}</span>

<span class="kd">class</span> <span class="nc">SubClass</span> <span class="kd">extends</span> <span class="nc">FinalMethod</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">drink</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 非 final 方法允许被重写</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>
<span class="o">}</span>

</pre></table></code></div></div><p>在这个代码中一共有两个类：</p><ol><li>第一个是 FinalMethod，它里面有一个 drink 方法和 eat 方法，其中 eat 方法是被 final 修饰的；<li>第二个类 SubClass 继承了前面的 FinalMethod 类。</ol><p>然后尝试对 drink 方法进行 Override，这当然是可以的，因为它是非 final 方法；接着尝试对 eat 方法进行 Override，你会发现，在下面的子类中去重写这个 eat 方法是不行的，会报编译错误，因为不允许重写 final 方法。</p><p>同时这里还有一个注意点，在下方又写了一个 public final SubClass () {}，这是一个构造函数，这里也是编译不通过的，因为<strong>构造方法不允许被 final 修饰</strong>。</p><h3 id="特例final-的-private方法"><span class="mr-2">特例：final 的 private方法</span><a href="#特例final-的-private方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>这里有一个特例，那就是用 final 去修饰 private 方法。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cm">/**
 * private 方法隐式指定为 final
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrivateFinalMethod</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">privateEat</span><span class="o">(){}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">SubClass2</span> <span class="kd">extends</span> <span class="nc">PrivateFinalMethod</span> <span class="o">{</span>
    <span class="c1">// 编译通过，但这并不是真正的重写</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">privateEat</span><span class="o">(){}</span>
<span class="o">}</span>

</pre></table></code></div></div><p>在这个代码例子中，首先有个 PrivateFinalMethod 类，它有个 final 修饰的方法，但是注意这个方法是 private 的。</p><p>接下来，下面的 SubClass2 extends 第一个 PrivateFinalMethod 类，也就是说继承了第一个类；然后子类中又写了一个 private final void privateEat() 方法，而且这个时候编译是通过的，也就是说，子类有一个方法名字叫 privateEat，而且是 final 修饰的。同样的，这个方法一模一样的出现在了父类中，那是不是说这个子类 SubClass2 成功的重写了父类的 privateEat 方法呢？是不是意味着我们之前讲的“被 final 修饰的方法，不可被重写”，这个结论是有问题的呢？</p><p>其实之前讲的结论依然是对的，但是类中的所有 private 方法都是隐式的指定为自动被 final 修饰的，额外的给它加上 final 关键字并不能起到任何效果。</p><p>由于这个方法是 private 类型的，所以对于子类而言，根本就获取不到父类的这个方法，就更别说重写了。</p><p>在上面这个代码例子中，其实<strong>子类并没有真正意义上的去重写父类的 privateEat 方法</strong>，子类和父类的这两个 privateEat 方法彼此之间是独立的，只是方法名碰巧一样而已。</p><p>为了证明这一点，尝试在子类的 privateEat 方法上加个 Override 注解，这个时候就会提示<code class="language-plaintext highlighter-rouge">Method does not override method from its superclass</code>，意思是“该方法没有重写父类的方法”，就证明了<strong>这不是一次真正的重写</strong>。</p><h2 id="final-修饰类"><span class="mr-2">final 修饰类</span><a href="#final-修饰类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>final 修饰类的含义很明确，就是这个类“<strong>不可被继承</strong>”。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// 测试 final 修饰类的效果</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">FinalClassDemo</span><span class="o">{</span>
    <span class="c1">// code</span>
<span class="o">}</span>
    
<span class="kd">class</span> <span class="nc">A</span> <span class="kd">extends</span> <span class="nc">FinalClassDemo</span><span class="o">{}</span> <span class="c1">//编译错误，无法继承final的类</span>


<span class="c1">//class A extends FinalClassDemo {}</span>

</pre></table></code></div></div><p>有一个 final 修饰的类叫作 FinalClassDemo，然后尝试写 class A extends FinalClassDemo，结果会报编译错误，因为语法规定无法继承 final 类，</p><p>给类加上 final 的目的是什么呢？如果这样设计，就代表自己不会继承这个类，也不允许其他人来继承，也就是不可能有子类的出现，这在一定程度上可以<strong>保证线程安全</strong>。</p><p>比如，非常经典的 String 类就是被 final 修饰的，所以自始至终也没有看到过哪个类是继承自 String 类的，这对于保证 String 的<strong>不可变性</strong>是很重要的。</p><p>有个注意点，假设某个类加上了 final 关键字，不代表里面的成员变量自动被加上 final。</p><p>事实上，这两者之间不存在相互影响的关系，也就是说，类是 final 的，不代表里面的属性就会自动加上 final。</p><p>不过 final 修饰方法的含义就是这个方法不允许被重写，而现在如果给这个类都加了 final，那这个类连子类都不会有，就更不可能发生重写方法的情况。</p><p>所以，在 final 的类里面，所有的方法，不论是 public、private 还是其他权限修饰符修饰的，都会<strong>自动的、隐式的被指定为是 final 修饰的</strong>。</p><p><strong>如果真的要使用 final 类或者方法的话，需要注明原因。</strong>因为未来代码的维护者，可能不是很理解为什么在这里使用了 final，因为使用后，对他来说是有影响的，比如用 final 修饰方法，就不能去重写了，或者说用 final 修饰了类，就不能去继承了。所以为了防止后续维护者有困惑，<strong>有必要或者说有义务说明原因</strong>，这样也不至于发生后续维护上的一些问题。</p><p>在很多情况下，并需要不急着把这个类或者方法声明为 final，可以到开发的中后期再去决定这件事情，这样的话，就能更清楚的明白各个类之间的交互方式，或者是各个方法之间的关系。所以可能会发现根本就不需要去使用 final 来修饰，或者不需要把范围扩得太大，可以重构代码，把 final 应用在更小范围的类或方法上，这样造成更小的影响。</p><h2 id="总结"><span class="mr-2">总结</span><a href="#总结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>final 用在变量、方法或者类上时，含义截然不同的：</p><ul><li>修饰变量，意味着一旦被赋值就不能被修改；<li>修饰方法，意味着不能被重写；<li>修饰类，意味着不能被继承。</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/java/'>Java</a>, <a href='/categories/concurrent/'>Concurrent</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/thread/" class="post-tag no-text-decoration" >thread</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=final 的三种用法 - ThinkerWalker&amp;url=/posts/final-three-uses/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=final 的三种用法 - ThinkerWalker&amp;u=/posts/final-three-uses/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=/posts/final-three-uses/&amp;text=final 的三种用法 - ThinkerWalker" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/use-spring-security-to-build-a-user-authentication-system/">Spring Security 的配置体系</a><li><a href="/posts/spring-data-jpa-test/">利用单元测试和集成测试</a><li><a href="/posts/query-annotation/">Spring Data JPA - @Query</a><li><a href="/posts/defining-query-methods/">Spring Data JPA - Defining Query Methods 的命名语法与参数</a><li><a href="/posts/cache-redis-02/">Redis 的数据类型</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/thread/">thread</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/design-pattern/">Design Pattern</a> <a class="post-tag" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a> <a class="post-tag" href="/tags/architecture-design/">Architecture Design</a> <a class="post-tag" href="/tags/backend-system/">Backend System</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/spring-security/">Spring Security</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/cache/">Cache</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/tread-Implementation/"><div class="card-body"> <em class="timeago small" data-ts="1549035180" > 2019-02-01 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>线程的实现方式 - 本质上只有一种</h3><div class="text-muted small"><p> 方式一：实现 Runbale 接口 class RunnableThread implements Runnable { @Override public void run() { System.out.println(&quot;使用实现 Runnable 接口实现线程&quot;); } } 步骤： 通过 RunnableThread 类实现 Runn...</p></div></div></a></div><div class="card"> <a href="/posts/tread-stop/"><div class="card-body"> <em class="timeago small" data-ts="1549121580" > 2019-02-02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>正确停止线程</h3><div class="text-muted small"><p> 启动一个线程非常简单，只需要两步： 在 run() 方法中定义需要执行的任务 调用 Thread 类的 start() 方法 但是，正确停止线程就没那么容了。 原理 通常情况下，我们不会手动停止一个线程，而是允许线程运行到结束，然后让它自然停止。 但是依然会有许多特殊的情况需要提前停止线程，比如： 用户突然关闭程序 程序运行出错重启等。 在这种情况下，即将...</p></div></div></a></div><div class="card"> <a href="/posts/thread-status/"><div class="card-body"> <em class="timeago small" data-ts="1549294380" > 2019-02-04 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>线程的六个状态</h3><div class="text-muted small"><p> 就像生物从出生到长大、最终死亡的过程一样，线程也有自己的生命周期，在 Java 中线程的生命周期中一共有 6 种状态。 New（新创建） Runnable（可运行） Block（阻塞） Blocked（被阻塞） Waiting（等待） Timed Waiting（计时等待） Terminated（被终止） ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/dining-philosophers-problem/" class="btn btn-outline-primary" prompt="上一篇"><p>哲学家就餐问题</p></a> <a href="/posts/final-fail/" class="btn btn-outline-primary" prompt="下一篇"><p>为什么加了 final 却依然无法拥有“不变性”</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/happymaya">superhsc</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/thread/">thread</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/design-pattern/">Design Pattern</a> <a class="post-tag" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a> <a class="post-tag" href="/tags/architecture-design/">Architecture Design</a> <a class="post-tag" href="/tags/backend-system/">Backend System</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/spring-security/">Spring Security</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/cache/">Cache</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
