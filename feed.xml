<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>ThinkerWalker</title><subtitle>ThinkerWalker, happymaya, superhsc, maya, imaya, thinkerwalker, 清锋, haoshichuan.</subtitle> <updated>2022-07-25T08:36:38+00:00</updated> <author> <name>superhsc</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 superhsc </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>简单原则：写出“简单”代码</title><link href="/posts/keep-it-simple-and-stupid/" rel="alternate" type="text/html" title="简单原则：写出“简单”代码" /><published>2022-04-12T14:21:22+00:00</published> <updated>2022-07-23T19:54:23+00:00</updated> <id>/posts/keep-it-simple-and-stupid/</id> <content src="/posts/keep-it-simple-and-stupid/" /> <author> <name>{"name"=>"superhsc", "link"=>"https://github.com/happymaya"}</name> </author> <category term="Design Pattern" /> <summary> 设计原则通常都有一个很普遍的特点：语言很简练， 听上去很有道理，但是拿来指导实践根本无从下手。比如说，在学习简单原则（ KISS 原则） 时，遇到过下列问题： 为什么身边的程序员都告诉你保持“简单”代码很重要？ 什么才是好的“简单”代码？ 如何能写出“简单”的代码？ YAGNI 原则和 KISS 原则是相同的吗？ 这些问题看上去简单，回答起来却不简单。所以，带着这些问题，重新学习 KISS 原则。 代码保持“简单”的必要性 KISS 原则（Keep It Simple and Stupid），翻译过来就是：保持简单，保持愚蠢。 KISS 原则自 1970 年起，就开始得到广泛使用。现在在软件开发中，KISS 原则通常是指代码应该更容易理解、更容易编写、更容易改变，并应该一直保持如此。 让代码保持“简单”主要三个重要原因： 防止代码腐坏。编程里有一个... </summary> </entry> <entry><title>最少原则：实现“最少知识”代码</title><link href="/posts/law-of-demeter/" rel="alternate" type="text/html" title="最少原则：实现“最少知识”代码" /><published>2022-04-11T07:03:00+00:00</published> <updated>2022-07-23T19:54:23+00:00</updated> <id>/posts/law-of-demeter/</id> <content src="/posts/law-of-demeter/" /> <author> <name>{"name"=>"superhsc", "link"=>"https://github.com/happymaya"}</name> </author> <category term="Design Pattern" /> <summary> 在日常编码中，经常会写下面这样的代码： final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); 上面的代码，看上去没有太大问题，但实际上其中任意一个方法发生变化时，这段代码都需要修改。 因为调用是依赖的每一个细节，不仅增加了耦合，也使代码结构僵化。 迪米特法则正是为了避免对象间出现这样过多的细节依赖而被提出来。 迪米特法则 迪米特法则（Law of Demeter，简称 LoD） 是由 Ian Holland 于 1987 年提出来，它的核心原则是： 一个类只应该与它直接相关的类通信； 每一个类应该知道自己需要的最少知识。 换句话说，在面向对象编程中，它要求任何一个对象（O）的方法（m），只应该调用以下对象： 对象（O）自身； 通过方法（m）的参数传入... </summary> </entry> <entry><title>分离原则：将复杂问题拆分成小问题</title><link href="/posts/separation-principle/" rel="alternate" type="text/html" title="分离原则：将复杂问题拆分成小问题" /><published>2022-04-10T14:45:20+00:00</published> <updated>2022-07-23T19:54:23+00:00</updated> <id>/posts/separation-principle/</id> <content src="/posts/separation-principle/" /> <author> <name>{"name"=>"superhsc", "link"=>"https://github.com/happymaya"}</name> </author> <category term="Design Pattern" /> <summary> 关注点分离原则是一个帮助我们将复杂问题拆分成小问题的好方法。 简单来说，在计算机科学中，关注点是能对程序代码产生影响的一组特定信息。比如： 在面向对象编程中，将关注点描述为对象； 在面向函数编程中，将关注点描述为函数； 在架构设计中，将模块、组件、框架描述为关注点，等等。 其实，在日常开发中或多或少涉及了关注点分离原则的具体实践。比如： 在分层架构中，按照服务类型来划分层，层就被作为一个关注点； 在类或方法的编码实现中，按职责分离，就是将职责作为一个关注点。 为什么应该使用关注点分离原则来拆分复杂问题？关注点分离原则到底说了些什么？它带来哪些启示？如何正确使用好这个原则？ 实际上，设计模式正是对关注点进行了有效分离才得以有效指导编程实践，所以为了高效地理解掌握设计模式，带着以上问题来一探究竟。 为什么要用关注点分离原则拆分复杂问题 从编码实现的... </summary> </entry> <entry><title>契约原则：做好 API 接口设计</title><link href="/posts/design-by-contract/" rel="alternate" type="text/html" title="契约原则：做好 API 接口设计" /><published>2022-04-10T09:03:00+00:00</published> <updated>2022-07-23T19:54:23+00:00</updated> <id>/posts/design-by-contract/</id> <content src="/posts/design-by-contract/" /> <author> <name>{"name"=>"superhsc", "link"=>"https://github.com/happymaya"}</name> </author> <category term="Design Pattern" /> <summary> 无论是架构设计还是编码实现，现在都越来越离不开接口设计，接口可以说是新时代的“集装箱”，是得到了几乎所有人一致共识的通用标准。 GoF 在很多年前便建议大家应该针对接口编程，原因就是：为了降低编程变化而导致风险出现的概率。 不过在实施过程中，可能遇见的更多是下面的情况： 定义好的 API 接口，却接收了额外的参数，导致程序异常退出； 查询返回的数据，没有回传预期的格式，数据处理出错； 一个 API 服务进行分布式部署，遗漏了某个节点，导致处理数据不一致。 如何平衡“约束”与“自由”之间的关系？ 如何更好地避免再发生上述情况？ 如何真正做好API 设计呢？ 契约式设计原则：API 设计的指导书 契约式设计原则（Design by Contract，缩写为 DbC，下文简称为“契约原则”），是一种软件设计方法。 原理是：在软件设计时应该为软件组件定义一... </summary> </entry> <entry><title>惯例原则：提升编程中的沟通效率</title><link href="/posts/coc/" rel="alternate" type="text/html" title="惯例原则：提升编程中的沟通效率" /><published>2022-04-10T03:30:20+00:00</published> <updated>2022-04-10T03:30:20+00:00</updated> <id>/posts/coc/</id> <content src="/posts/coc/" /> <author> <name>{"name"=>"superhsc", "link"=>"https://github.com/happymaya"}</name> </author> <category term="Design Pattern" /> <summary> 在软件开发中，经常因为沟通效率低下而烦恼，就像： 所接手的维护项目代码质量低，频繁出问题，不得不一次又一次地找之前的人沟通； 团队中模块分散，各自编程风格不同，使用对方服务时需要反复沟通； 跨团队合作沟通，技术栈不同，需要反复沟通统一的标准。 这些问题的本质都是因为代码而产生了学习成本和沟通成本，或者说，每一份代码都变成了需要重新学习的东西，自然需要反复研究和沟通。 为什么学习了 Spring 框架后，再和别人交流关于这个框架的问题时沟通效率会变高？因为 Spring Boot 框架应用了一个简单的原则来帮助我们提前建立了隐形的公共知识体系，当一方提到某个知识时，另一方其实早就非常熟悉，不需要反复给对方解释含义，沟通效率自然会不断提高。而这个具备强大威力的原则：惯例优于配置原则（下文简称惯例原则）。 惯例原则：有“共同语言”的编程 惯例原则（Convention... </summary> </entry> </feed>
